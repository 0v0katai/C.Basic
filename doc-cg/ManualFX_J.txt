===============================================================================

アドイン版　Casio Basic Interpreter (& Compiler) ver 1.6 ベータ版　マニュアル

copyright(c)2015/2016/2017 by sentaro21
e-mail sentaro21@pm.matrix.jp


===============================================================================
C.Basicとは？
===============================================================================
純正Casio Basicとfx-5800Pの使い勝手のいいとこ取りを目指した高速互換CasioBasicです。
プログラムソースはストレージメモリ上に置かれますが、サポートコマンドの範囲内ではファイルフォーマット及び動作の互換があります。


===============================================================================
使用可能メモリ
===============================================================================
アドインとして自由に使用できるRAMは64KBありますが、そのうち16KBがスタックエリア、
さらに8KBがアドインのグローバル変数エリアとして使われるので残りの40KBが自由に使えるエリアとなります。
C.Basicでは各種バッファエリアとして数KBを確保した残りの36KB程度がフリーエリア（プログラムと行列で使えるエリア）となっています。
fx-9860GII以降は使われていないRAMが256KB存在しているのでそれを使用することで、256KB以上のフリーエリアを実現しています。


===============================================================================
内蔵エディタでの編集可能サイズ
===============================================================================
C.Basicでは標準のエディタと同様の使い勝手を目指したエディタを内蔵しています。
コピー＆ペーストは使えますが一度にコピーできるサイズは2KBが最大です。アンドゥは未実装です。

新規ファイルの初期編集可能サイズは4KBとなっています。
プログラム作成時にこのサイズを超えると編集できなくなるので一旦保存後再編集して下さい。
再編集時のプログラム編集可能最大サイズはプログラムサイズ+2KBとなっています。

プログラム実行時にはメインプログラムはメインプログラムサイズ+2KB、サブプログラムはサブプログラム+256Bの編集可能エリアを確保した上で実行されます。
デバッグモード時での再編集可能サイズとなります。

プログラム編集可能最大サイズは、隠しRAMを使わない標準設定で約20〜30KB程度となります。（ストレージ上のファイル数によって編集可能サイズが変わります。）
隠しRAMを使用する場合には約62KBまでのファイルを編集、実行することが出来ます。


===============================================================================
内蔵デバッグモード
===============================================================================
純正には無い機能として[AC]で中断したプログラムの再開、及びデバッグモードを装備しています。
デバッグモードは最初の実行時よりデバッグモードで起動することも出来ます。
トレース実行、１ステップ実行、ステップオーバー、ステップアウトをサポートしています。


===============================================================================
実行モードについて
===============================================================================
C.Basicでは純正CasioBasic同様の実数モードと、整数値しか扱えない整数モードがあります。
それぞれの実行モードの切り替えはコメント欄で
'#CBasic
'#CBASIC
'#CBDBL
'#CBdbl
と記述するとそれ以降、実数モードに、

'#CBINT
'#CBint
と記述すると整数モードになります。

また、Setupからデフォルトの実行モードが設定できます。
コメント欄での変更はセットアップでの変更に優先します。

整数モードでは得られる結果がすべて整数値となりますが、
整数値しか扱わないプログラムでは実数モードに比べて1.5倍以上速くなります。


整数モードで実数を扱いたい場合は、式の前に＃を付けると＃以降の式を実数モードで計算します。ただし式の結果は整数値に丸められます。
（例）＃100×Frac 1.23  + 5
　整数モードではFlac 1.23は数値エラーになって実行できませんが、＃を付けると
　＃(Frac 1.23×100 + 5)
　＃以降の式を実数計算することが出来るようになるので、結果は実数モードと同じく28になります。

　式の途中に＃がある場合は、その＃以降、式の終わり（区切り記号まで）まで実数計算します。
（例）100×＃Frac 1.23 + 5
　式の解釈は
　100×＃(Frac 1.23 + 5)となるので実数モードでは523、整数モードでは500になります。


===============================================================================
実行時ウエイトについて
===============================================================================
全体の実行速度を調整することが出来ます。
セットアップで設定した場合は全部のプログラムが影響を受けます。

個々のプログラムで調整したい場合はWaitコマンドを使用します。
（例）Wait 100
ウエイト値に100を設定します。


===============================================================================
扱える数値について
===============================================================================
純正CasioBasicでは内部15桁、指数2桁の精度を持つ10進数ですが、
C.BasicではSDKのCの仕様と同じ64ビット倍精度実数型と32ビット整数型が基本になります。
倍精度実数型で扱える数値範囲は
±9.88131291682493e-323〜±1.7976931348623151e+308
純正よりは広い範囲の数値が扱えますが、演算は2進数で行われるので小数以下の数値を扱う場合は誤差に注意して下さい。

定数値において、C言語同様のプレフィックス(0Xまたは0B）を付けると32ビットまでの16進数、2進数が使用出来ます。
（例）0XFF, 0B10100110
（例）0xAB, 0b10100110


===============================================================================
変数について
===============================================================================
純正CasioBasic同様に1文字変数としてA〜Z、r、θまでの28文字に加えてa〜ｚまでの小文字変数が使えます。
2文字以上の変数名には純正CasioBasic同様対応していません。
変数は実行モードの違いに関係なくそれぞれ独立した実数変数（A〜Z、r、θ、a〜ｚ）と整数変数（A〜Zr、θ、a〜ｚ）が確保されますが、
そのままでは変数名の区別ができないので、％サフィックスを付けると整数変数（A%〜Z%、r%、θ%、a%〜ｚ%）、＃サフィックスを付けると実数変数（A#〜Z#、r#、θ#、a#〜ｚ#）となります。
実数モードで％サフィックスを付けた整数変数を使う場合は特に気にすることはないのですが、
整数モードで＃サフィックスを付けた実数変数を使う場合は、変数からの読み出し結果はすべて整数の範囲に丸められます。
実数値が整数範囲に収まらない場合は0になります。

（例）'#CBINT		//　整数モード指定
　　　1.2345→A#	//　実数変数Aに1.2345を代入したつもりが実際には整数の1が代入されます。

（例）A％→A＃
　整数変数のAより倍精度変数Aにコピーします。
　整数から倍精度へのコピーは無問題ですが、倍精度値から整数値にコピーする場合、整数範囲に収まらない場合は0になります。

変数の初期化では純正同様の0→A〜Zの形式に加えて、整数、倍精度、個別に指定できます。
0→A〜Z＃
倍精度変数を初期化します。
0→A〜Z％
整数変数を初期化します。


===============================================================================
画面描画について
===============================================================================
fx-9860GIIでは画面表示はVRAMに描かれたデータをLCDに転送することで表示するようになっています。
LCDへの転送はかなりのオーバーヘッドがあるので、描画コマンドの実行の度にLCD転送するのは非効率です。
そのためにC.Basicではコマンド終了時に毎回、VRAMからLCDへの転送（＝リフレッシュ）を行わずに
一定の時間が経ってからリフレッシュするように設定出来ます。（セットアップおよびコマンドで可能です）
この時、次回のリフレッシュされるタイミングよりも描画コマンドが早く終了した場合は、
LCD転送されず画面に表示されることなく次の処理に移ってしまうということが起きる場合がありますので
転送漏れを無くすためには区切りのいいところで強制的にLCD転送させるためにPutDispDDコマンドを使用して下さい。

===============================================================================
VRAMについて
===============================================================================
C.Basicでは純正CasioBasic同様にテキスト画面とグラフィックス画面がそれぞれ独立して存在していますが、
コマンド等で画面描画に使われるVRAMとしてはひとつだけであり、これを表示用VRAMとします。
さらに
テキストVRAM＝テキストモードでのVRAM内容を保持しているRAMエリア、
グラフィックVRAM＝グラフィックモードでののVRAM内容を保持しているRAMエリア、
を持っています。
つまり3画面分の同じサイズのVRAMが存在しています。
通常のコマンドで描画対象になるのは表示用VRAMです。

例えば、テキスト系の描画コマンドが実行される場合、
現在の画面モードがテキストモードであれば、そのまま表示用VRAMに描画を行います。
グラフィックモードであれば、表示用VRAMをグラフィックVRAMに退避転送した後、テキストVRAMの内容を表示用VRAMに復帰転送して、表示用VRAMに対してテキスト描画を行います。
この後、テキスト系の描画コマンドが続く場合は、表示用VRAMの退避転送は行われず、そのまま表示用VRAMに対して描画を行います。
グラフィック系コマンドが実行された場合は、表示用VRAMをテキストVRAMに退避転送した後、グラフィックVRAMの内容を表示用VRAMに復帰転送して、表示用VRAMに対してグラフィック描画を行います。
このようにテキストVRAMとグラフィックVRAMは直接描画が行われる領域ではなく単なる保存領域となっていて、テキストモードとグラフィックモードを切り替えが起きると、その都度、表示用VRAMとの入れ替えが行われます。
表示用VRAMに描画しただけではLCDに表示されることはなく、LCD転送されて初めてLCD画面に表示されることになります。


===============================================================================
行列の拡張について
===============================================================================
純正CasioBasicのMatrix行列との違いについて説明します。

通常モードでは純正と同じく実数モードでは実数の行列、整数モードでは整数の行列として使用できますが、
C.Basicでは実数（8バイト）および整数（4バイト）の他に、1ビット、バイト（1バイト）、ワード（2バイト）の型を持つ行列が使えます。

行列確保時にサフィックス指定すると要素の型指定ができます。
[.P]または[.p]で（1ビット）整数バイナリー行列。扱える値の範囲は（0〜1）です。
[.B]または[.b]で（8ビット）整数バイト行列。扱える値の範囲は（-128〜127）です。
[.W]または[.w]で（16ビット）整数ワード行列。扱える値の範囲は（-32768〜32767）
[.L]または[.l]で（32ビット）整数ロングワード行列。扱える値の範囲は（-2147483648〜2147483647）
[.F]または[.f]で（64ビット）倍精度実数行列。扱える値の範囲は（±9.88131291682493e-323〜±1.7976931348623151e+308）

行列は純正同様に｛ｍ，ｎ｝型で｛row(行）,column（列）｝での実装となります。
例外として1ビット型は｛X,Y}型の実装で｛column（列,）row(行）｝での実装となります。

1ビット行列は画面のVRAMと同じ構成となるので、
[.V]または[.v]指定するとVRAMを128行x64列の行列に割り当てて読み書きが出来ます。
さらに[.VG]でグラフィックVRAM、[.VT]でテキストVRAMを行列に割り当てることが出来ます。
尚、インデックスベースは0から始まり、行列サイズは{128,64}固定となります。

（例）{128,64}→Dim Mat G.V
　Mat Gにアクセスすることでその時点でのVRAMを直接読み書きできますが表示系コマンドではないので、
　画面表示する場合は、コマンド実行後に強制表示させる必要があります。

（例）{128,64}→Mat G.V
　　　Screen.G	//　グラフィック画面選択（他のグラフィックコマンドでも可）
　　　1→Mat G[63,31]
　　　PutDispDD	//　画面転送コマンド
　　　グラフィック画面の真ん中に点を打ちます。
　　　PxlOn 31,63と同じです。

（例）{128,64}→Mat G.V
　　　Screen.T	//　テキスト画面選択（他のテキスト系コマンドでも可）
　　　1→Mat G[63,31]
　　　PutDispDD	//　画面転送コマンド
　　　テキスト画面の真ん中に点が打てます。


===============================================================================
行列の初期化
===============================================================================
純正同様に、
{m,n}→Dim Mat A形式と、
[[1,2,3][4,5,6]]→Mat A形式の初期化をサポートしています。

さらに、fx-5800Pでの
100→Dim A
形式をサポートしています。
0→Dim A
行列Aを消去します。


行列要素の一括初期化として純正同様のFillコマンドと数値→Mat Aという形式をサポートしています。
（例）Fill(123,Mat A)
（例）123→Mat A
Mat A行列の全要素を123で初期化することができます。


Mat行列初期化コマンド[[ ]]において、改行＆空白を入れることが可能です。
（例）
　[[0B11001100,
　　0B00110011,
　　0B11001100,
　　0B00110011
　]]→Mat A.B

===============================================================================
行列へのアクセス
===============================================================================
通常のMat A[1,1]形式に加えて、
Matを省略した
A[1,1]
一列目だけのアクセスでは
A[1]
表記も可能です。

さらに添字が数値の0〜9の場合のみ、
A0
A5
表記が出来ます。

この表記の変数は実体となる行列が事前に確保されて無い場合は、自動的に行列が確保されます。
（例）A1+123→B5
　もし、Mat AおよびMat Bが確保されていない場合は、変数がアクセスされた時点で
　9→Dim A
　9→Dim B
　と同じ初期化が自動的に実行され、A1〜A9およびB1〜B9までが使えます。

（例）'#Mat 0
　A1+123→B5
　の場合、もし、Mat AおよびMat Bが確保されていない場合は、
 　10→Dim A
 　10→Dim B
　と同じ初期化が自動的に実行され、A0〜A9およびB0〜B9までが使えます。

（例）'#Mat 0
　2→Dim B
　A1+123→B5
　の場合は、
 　10→Dim A
　Mat Aのみ初期化され、Mat Bは再確保されないのでB5にアクセスした時点でエラーになります。
　この場合はA0〜A9およびB0〜B1までが使えます。

===============================================================================
行列の転置変換
===============================================================================
純正CasioBasicと同じTrnコマンドをサポートしていますが純正CasioBasicとは違い、行列そのものを転置変換します。
（例）Trn Mat A
　行列Aを転置変換します。

*Ver.1.10より純正互換となりました。
（例）Trn Mat A
　行列Aを転置変換しMatAnsに結果を代入します。
（例）Trn Mat A->Mat A
　行列Aを転置変換します。
（例）Trn Mat A->Mat B
　行列Aを転置変換しMat Bに結果を代入します。

===============================================================================
行列の要素サイズ変更
===============================================================================
行列の型(1ビット、バイト、ワード、ロングワード、実数）は行列確保後でも任意に変更できます。
（例）[[1,2,3,4][5,6,7,8]]→Mat A.B
　　　Mat A→Dim Mat A.W
　バイト型のMat A行列をワード型に変更できます。
　要素数は変更後の型サイズに応じて変化します。
　[[0x12,0x34][0x56,0x78]]→Mat A.W
　と同じ結果になります。

（注意）１ビット型行列からの変更、また１ビット型行列への変更は行と列が反転します。
　これは１ビット型行列はX,Y型で実装しているために通常のm,n型行列とは転置行列の関係になります。
　{127,63}→Dim Mat A.P
　LCD画面の全画面ビットマップデータの仮想メモリとして利用できるバッファとして確保します。
　Mat A→Dim Mat A.B
　バイト型行列に変更すると、
　要素サイズは{63,16}になります。


===============================================================================
行列のインデックス開始値について
===============================================================================
純正CasioBasicでは行列のインデックスは１から始まりますが、C.Basicでは0から始まることができます。
セットアップもしくはコメント欄での記述で行列の始まりを選択できます。
（例）#Mat 1
　　従来通り1から始まります。
（例）#Mat 0
　　{3,2}→Dim Mat A
 　確保される行列は A[0,0]〜A[2,1]となります。

　同時に画面座標も0まで有効になります。これで全画面が描画対象エリアとなります
（例）Pxlon 0,0


===============================================================================
行列の表示について
===============================================================================
Mat行列エディタにおいて2進数、16進数での表示ができます。
行列編集モードで[F5]を押すと2進数表示、[F6]で16進数表示になります。
10進数表示に戻すには再度[F5][F6]を押します。
ただし、2進数表示はバイト（1バイト）とワードタイプ（2バイト）の行列までです。

[OPTN]キーを押すとリスト名表示に変わります。
[VARS]キーを押すと文字列表示に変わります。

行列編集でドット編集の出来るモードを追加しました。（Ver.1.62以降）
行列を表示している状態で[OPTN]キーを押すとドットエディタになります。
行列の各要素の値が0の場合とそれ以外でドットの白黒が決まります。

行列のデータをクリップボードにコピー＆ペーストが可能になりました。（Ver.1.62以降）
行列編集モード時に[SHIFT]+[8](CLIP)でコピー、[SHIFT]+[9]でペースト出来ます。
（C.Basic）形式なのでエディタにて行列データをペースト出来ます。


===============================================================================
行列のインデックス拡張および最大インデックス値について
===============================================================================
行列のアクセスは純正同様にMat+英１文字以外に、Listと同じく数値で指定できるようになりました。 （Ver.1.64以降）
（θ、ｒ、Ansは数値指定できません。）
Mat A  = Mat 1
Mat B  = Mat 2
Mat C  = Mat 3
Mat Z  = Mat 26
Mat a  = Mat 27
Mat z  = Mat 52

さらに＠を付けるとインデックス値を変数で指定することも出来ます。
（例）3->A
      Mat @A （Mat Cと同じです）

Listの拡張で行列も同様に最大1040まで拡張されます。（Ver.1.61以降）


小文字以降の行列はリストと共用しているために27以降の行列＝小文字行列はリストと同じ領域を使用します。（Ver.1.64以降）
53以降は数値のみ指定できます。
Mat a[5,1] = Mat 27[5,1] = List 27[5]
Mat b[5,1] = Mat 28[5,1] = List 28[5]
Mat c[5,1] = Mat 29[5,1] = List 29[5]
Mat z[5,1] = Mat 52[5,1] = List 52[5]

List 53[5]   = Mat 53[5,1]
List 100[5]  = Mat 100[5,1]
List 1000[5] = Mat 1000[5,1]

（例）100->A
      Mat @A
 Mat @AはMat 100、List 100と同じで。


===============================================================================
リスト機能のサポート範囲について
===============================================================================
リスト機能は行列機能を利用して実装しています。
デフォルトでList 1〜52まで使えます。（Ver.1.57以降）
さらに隠しRAM使用時にはセットアップで1040まで増やすことが出来ます。（Ver.1.61以降）
Listと行列との対応は以下の通りになっています。
Mat A〜ZおよびList 1〜26は互いに独立しています。
27〜52までは小文字の行列と共有します。
List 27[5] = Mat a[5, 1]
List 28[5] = Mat b[5, 1]
List 29[5] = Mat c[5, 1]
List 52[5] = Mat z[5, 1]
List 100[5] = Mat 100[5, 1]
List 1000[5] = Mat 1000[5, 1]


純正機能の以下のコマンドをサポートしています。

List Ans
10->Dim List 1
{1,2,3,4,5}->List 1
Seq( X^2, X, 1, 10, 2 )->List 2
Augment(List1,List2)->List 3
Mat>List( Mat A, 2) -> List 1
List>Mat( List 1, List 2,..) -> List 9
Fill(3,List 1)
Min(List 1)
Max(List 1)
Mean(List 1）
SortA(List 1)
SortB(List 1)
Sum List 1
Prod List 1

Listを含む四則演算および関数演算。


===============================================================================
文字列について
===============================================================================
純正CasioBasicと同じくStr文字変数や文字列関数が使えますが、文字列の実体は行列として実装しています。

プレフィックスとして$を付けることでMat行列は文字列として認識されます。
（例）["ABCDEF"]→Mat A
　　　Locate 3,3,$Mat A
　画面座標(3,3)に"ABCDEF"が表示されます。

　最初に
　{7,1}→Dim Mat A.B
  と同じ初期化が自動的にされます。
　そして文字列は行列内ではバイト型データとして格納されます。


・CasioBasic互換で使える文字列関数
 +　（文字列同士の連結）
 StrJoin(
 StrLen
 StrCmp(
 StrSrc(
 StrLeft(
 StrRight(
 StrMid(
 Exp>Str(
 Exp(
 StrUpr(
 StrDwr(
 StrInv(
 StrShift(
 StrRotate(

（例）"ABCDEF"→Str 1
　　　Locate 3,3.StrRight(Str 1, 3)
　画面座標(3,3)に"DEF"が表示されます。


fx-9860GIIで使われる文字は１バイト文字（英数字、一部のコマンド）と２バイト文字（ほぼすべてのコマンド、特殊文字およびカナ）があり、
内部では１バイトと２バイト文字が混在する状態となりますが、文字関数での扱いは純正同様にすべて１文字扱いとなります。
文字列が格納された行列要素に直接アクセスする場合は文字の位置に注意して下さい。


===============================================================================
文字列の初期化について
===============================================================================
純正と同じ文字変数Str 1-20はデフォルトではMat行列のｒを暗黙的に使用します。
デフォルトでは文字数が255文字までとなっています。
Str文字変数は自動的にMat行列として確保され、次の文字列コマンドにおいては純正互換で使えるので、行列を意識する必要はありません。
Str文字列の初期化は何も指定なければ次のようにMat ｒ行列の初期化が自動的に行われます。
　{20,65}→Dim Mat ｒ

なお、Str文字変数の実体となるMat行列は任意指定することも出来、Str変数を使う前にコメント欄で指定します。
（例）'#Str A
　Str変数をMat Aとして確保します。
　{20,65}→Dim Mat A.B
　と同じです。
（例）'#Str B,30,256
　Str変数をMat Bとして30個、255文字まで可能な変数として確保します。

文字列の代入は次の書式が使えます。
（例）"ABCDEEF"→Str 1
（例）["ABC","TEST","1+3+5"]→Mat A
　バイト型のMat A[3,6]行列を自動的に確保してそれぞれの要素に文字列を配置します。
 　Mat A[1,1]="ABC"
 　Mat A[2,1]="TEST"
 　Mat A[3,1]="1+3+5"
　となります。
　文字列対応コマンドで"ABC"にアクセスするには$Mat A、もしくは$Mat A[1],もしくは$Mat A[1,1]となります。
　"1+3+5"をアクセスするには$Mat A[3],もしくは$Mat A[3,1]となります。
（例）Locate 1,1,$Mat A
　Locate 1,1,"ABC"と同じです。
（例）Locate 1,1,$Mat A[3,3]
　Locate 1,1,"3+5"と同じです。

現バージョンでの文字列対応コマンドです。””の代わりに$Mat形式で使用します。
・””
（例）$Mat A[1]
　　"ABC"と同じです。
・？
（例）？→$Mat A
　行列Mat Aに文字列を入力します。確保している要素数で文字数が制限されます。
・Locate
・Text
・LocateYX
・Eval(
（例）Eval("1+2+3")→6
（例）Eval($Mat[3,3])→8
 文字列を数式として評価、値を返します。


===============================================================================
拡張文字列コマンドSprintfについて
===============================================================================
純正には数値から文字列への変換関数が無いので、追加の文字列関数としてSDKのC言語互換仕様のSprintf(を追加しました。
（仕様）Sprintf( "書式指定子" , 引数１[ ,引数２ [, 引数３]])
（例）Sprintf("A=%4d B=%3.2f",%A,#B)→Str 1
　 A=1234,B=45.678の場合、
　Str 1に代入される文字列は
　"A=1234 B=45.68"
　となります。
　書式指定はC言語でのsprintfと互換仕様となりますので指数表記等の数値表現が若干違います。
  引数は3つまで指定することが出来、整数/実数/文字列が指定可能です。
　％プレフィックスで整数指定、＃プレフィックスで実数指定となります。
  プレフィックスを省略した場合はその時点での実行モード（実数/整数）となります。
  書式指定と引数の対応のエラーチェックは無いので、Sprintf(コマンドでエラーが起きた場合はリセットか再起動となる可能性がありますので注意して下さい。


===============================================================================
コマンドリファレンス
===============================================================================
フルサポート及び一部サポートされているCacio Basic互換コマンド
===============================================================================
?
▲　(Disps)
→
If 〜 Then 〜 Else 〜 IfEnd
Lbl 〜 Goto
=  !=  >  <  >=  <=

Dsz / Isz
=>
Locate
Menu

For 〜 To 〜 Step 〜 Next
While 〜 WhileEnd
Do 〜 LpWhile
Break
Return
Stop
Getkey
Prog

ClrMat
ClrList
Mat　（配列としての実装で行列演算機能は未サポートです。）
List　（Listを含む演算をサポートしています。）
Dim
Fill(
Seq(
Augment(
Mat>List(
List>Mat(
Min(
Max(
Mean(
SortA(
SortB(
Sum
Prod

Cls ClrText ClrGraph
ViewWindow
Plot / PlotOn / PlotOff / PlotChg
Circle
Line / F-Line
Vertical / Horizontal

PxlOn / PxlOff / PxlChg
PxlTest(
Text


SketchNormal / SketchThick / SketchBroken / SketchDot
S-L-Normal   / S-L-Thick   / S-L-Broken   / S-L-Dot

G-Connect / G-Plot
CoordOn / CoordOff
GridOn / GridOff
AxesOn / AxesOff
LabelOn / LabelOff
BG-None / BG-Pict

DrawGraph	(一部サポート）
Graph Y=	(一部サポート）
GraphY		(一部サポート）

Graph(X,Y)=	(一部サポート）
DrawStat	(一部サポート）
S-Gph1、S-Gph2、S-Gph3、DrawOn、DrawOff、Scatter、xyLine、Square、Cross、Dot

Xmin  Ymin  Xmax  Ymax  Xscl  Yscl  Xfct  Yfct  Xdot
TθMin  TθMax  TθPtch

Deg Rad Grad

And  Or  Not  Xor

Abs  Int  frac Intg
!
MOD(
Rmdr Int÷
log      ln     logab(
10^x     e^x
x^-1
sqr      x^2
sqr^-3
sin      cos      tan
sin^-1   cos^-1   tan^-1
sinh     cosh     tanh
sinh^-1  cosh^-1  tanh^-1

femto  pico  nano  micro  milli  Kiro  Mega  Giga  Tera  Peta  Exa

°(deg) r (rad) g (gra)
° >DMS

Str
StrJoin(
StrLen
StrCmp(
StrSrc(
StrLeft(
StrRight(
StrMid(
Str>Exp(
Exp(
StrUpr(
StrDwr(
StrInv(
StrShift(
StrRotate(

StoPict / RclPict

Ran#  RanInt#(
Rnd  RndFix(
Norm / Fix / Sci
Eng / EngOn / EngOff



===============================================================================
コマンドリファレンス　拡張コマンド
===============================================================================
-------------------------------------------------------------------------------
Eng,Norm,Fix,Sci
-------------------------------------------------------------------------------
Eng,Norm,Fix,Sciの状態の読み出しが可能です。
Engモードは変数(Eng)で取得できます。
返り値0：EngOff
返り値1：EngOn
返り値3：EngOn 3 (3桁区切り）

Norm、Fix、Sci
はそれぞれ引数に負数を指定すると現在の設定値を返します。
※引数の()は無くても構いません。

現在の設定がNorm1の場合の返り値は、
Norm (-1)で1
Fix (-1)では-1
Sci (-1)では-1

現在の設定が　Fix 8の場合は、
Norm (-1)で-1
Fix (-1)では 8
Sci (-1)では-1
になります。

-------------------------------------------------------------------------------
EngOn
-------------------------------------------------------------------------------
　3桁区切りも可能になります。
（例）EngOn 3
  このコマンド以降の数値出力が3桁区切りになります。
　EngOffで通常モードに戻ります。

-------------------------------------------------------------------------------
StoPict/RclPict
-------------------------------------------------------------------------------
ストレージメモリと内部ヒープメモリで動作するモードを切替できます。
セットアップにてストレージメモリとの切り替え動作になります。
ヒープメモリ指定の場合はPictファイルの互換が無くなる代わりに速度向上しました。
Basic動作上の互換性は確保されていますので、純正CasioBasicのソースはそのままで動きます。


-------------------------------------------------------------------------------
ElseIf
-------------------------------------------------------------------------------
（書式）If〜Then〜ElseIf〜IfEnd
（例）
 If A:Then
    Locate 1,1,"A"
 ElseIf B:Then
    Locate 1,2,"B"
 EndIf

・Ifに対応するIfEndが無い場合にエラーとするかどうかをセットアップで選択出来ます。
　セットアップでチェックをOnにすれば実行時に対応するIfEndが無いIfコマンドの箇所でエラーになります。


-------------------------------------------------------------------------------
Locate
-------------------------------------------------------------------------------
・Locateコマンドの表示で反転表示が可能です。
　コマンドの最後に[,R]で反転表示となります。
（例）Locate 1,2,"Test",R
　　"Test"がグラフィック座標(1,2)に反転表示で表示されます。

・Sprintf、Locate、Text, Dispコマンドでの＃プレフィックスは実数式評価となります。
　整数モードでは常に整数値しか得られないので、＃プレフィックスを付けた式では実数式評価で実数値が返ります。
　整数モードでしか意味は無いのですが整数モードにおけるSprintfやLocate、Textコマンドで実数値を扱うことが出来ます。

（例）'#CBINT
      10→A
      Locate 1, 2, log 123+A
　整数モードでは整数値に丸められて12となってしまうのですが、
（例）'3CBINT
      10→A
      Locate 1, 2, #log 123+A
　＃プレフィックスを付けると12.089905111と表示されます。
　＃以降の式評価は実数式として行われますが、変数は整数変数のまま扱われます。％を付ける必要はありません。


-------------------------------------------------------------------------------
Switch
Case
Default
SwitchEnd
-------------------------------------------------------------------------------
（説明）Switchコマンドを追加しました。C言語同様フォールスルー可です。ただしDefaultは最後でないと期待した動作になりません。
　　　　新規コマンドはSwitch、Case、Default、SwitchEndとなります。Breakは従来コマンドです。
（例）
  Switch A:
    Case 1:Locate 1,1,"A"
        Break
    Case 2:Locate 1,2,"B"
    Case 3:Locate 1,3,"C"
        Break
    Default
        Break
  SwitchEnd


-------------------------------------------------------------------------------
ACBreak
-------------------------------------------------------------------------------
（説明）プログラム中で[AC]での一時中止と同じ結果となります。
　セットアップにてACBreakコマンドの有効/無効の切り替えが出来ます。
　無効(off)にした場合はスルーされてプログラムの実行に何も影響を及ぼしません。
（書式）ACBreak

（例）ACBreakStop
　直後にStopコマンドを付けることで、ACBreakStopとなりますが、
　これ以降に実行されるACBreakコマンドをすべてキャンセルします。
　セットアップでのキャンセルと同じです。


-------------------------------------------------------------------------------
Local
-------------------------------------------------------------------------------
（説明）デフォルトでは小文字変数は全てグローバル変数扱いですが、任意の小文字変数をローカル変数とすることが出来ます。
　　　　プログラム内でLocalコマンドで変数指定するとその変数はそのプログラム内だけで使われるローカル変数となります。
（例）Local x,y,x
　ローカル変数としてｘ，ｙ，ｚを指定します。
　指定できるのは小文字変数のみで最大10個まで指定できます。
　またこの変数の順で引数付きのProgとGosubでローカル変数に代入されます。

（例）サブプログラム"TEST"内で、
　　　Local x,y,x
　（記述する位置はサブプログラム内であればどこでも可ですが、同じサブプログラム内で複数のLocalがある場合は最後に記述されたLocalのみが有効になります。）

　　　Prog "TEST",123,456,N
　サブプログラム"TEST"の実行時に、ローカル変数としてx,y,zが確保され、
　123→x、456→y、N→z、それ以外はグローバル変数となります。

ローカル変数が使えるようになったことで再帰プログラムも可能になりますが、
現状ではメモリ制限でネスト30層程度までとなっています。


-------------------------------------------------------------------------------
Prog
-------------------------------------------------------------------------------
（説明）Localコマンドを使うことで引数を記述することが出来ます。
（例）
　"MAIN"プログラム
　  10→X
　  20→Y
    X+1→a
    Y×2→b
　  Prog "SUB",X,Y
　　Disp Ans
    Disp a
    Disp b

　"SUB"プログラム
　  local a,b
    Dips a
    Disp b
　　Return a+b
-------------実行結果
      10
      20
      30
      11
      40
-------------

　2つの数値の和を計算するサブプログラムを呼び出し結果を表示します。
　サブプログラム内ではa,bはローカル変数として確保され、サブプログラム内ではグローバル変数a,bにはアクセス出来ません。
　メインプログラムのa,bはグローバル変数であり、サブプログラムのa,bの影響を受けません。


-------------------------------------------------------------------------------
Return
-------------------------------------------------------------------------------
（説明）サブルーチンからメインルーチンに戻ります。返り値を指定することができます。
（例）Return　式
　　返り値をAnsに代入してメインルーチンに戻ります。

　計算結果は常にAnsに代入されるので、

　式
  Return

　でも同じ結果になります。


-------------------------------------------------------------------------------
Gosub
-------------------------------------------------------------------------------
（説明）単一のプログラム内でサブルーチンが使えます。
（例）Gosub A
　Label Aから始まるプログラムを実行しReturnコマンドで復帰します。
（例）Gosub A,123,456
　引数もProgコマンド同様に使えます。

（例）
　  10→X
　  20→Y
    X+1→a
    Y×2→b
　  Gosub A,X,Y
　　Disp Ans
    Disp a
    Disp b
    Stop

    Lbl A
　  local a,b
    Dips a
    Disp b
　　Return a+b
-------------実行結果
      10
      20
      30
      10
      20
-------------

　Progコマンドでのプログラム例を、Gosubを使用するプログラムに書き換えたプログラムです。
　a,bはローカル変数として確保され、このプログラム内ではグローバル変数a,bにはアクセス出来ません。


-------------------------------------------------------------------------------
ElemSize(
ColSize(
RowSize(
-------------------------------------------------------------------------------
（説明）行列のサイズを取得する関数です。
（書式）ElemSize( 行列名 )

　１要素のサイズ（ビット）を返します。
（例）　ElemSize( Mat A )

（書式）ColSize( 行列名 )
　{m,n}のm，行サイズを返します。
（書式）RawSize( 行列名 )
　{m,n}のn，列サイズを返します。

-------------------------------------------------------------------------------
MatBase(
-------------------------------------------------------------------------------
（説明）行列のインデックス開始値を取得する関数です。
（書式）MatBase( 行列名 )
（例）MatBase(Mat A)
　行列Mat Aのインデックス開始値を返します。0か１になります。

-------------------------------------------------------------------------------
Getkey
-------------------------------------------------------------------------------
（説明）純正コマンドの機能に加えて、
　　　　キーが押されるまで待つGetkey1（SDKのGetkeyと同じ）
　　　　キーバッファをクリアしてから入力するGetkey2
　　　　さらに一定時間キー入力待ちをするGetkey3
	複数キーの同時読み込みをリストで返すGetkeyM
	があります。
　　　　キーコードはSDK互換ではなくCasioBasicのGetkey互換です。
　　　　SH4A版のfx-9860GIIのGetkeyコマンドにてGetkey1〜2と同様に[SHIFT]+[OPTN]でのバックライト制御が可能です。
　　　　[SHIFT]+[AC]での電源OFFには未対応です。

（例）Getkey3(128)
　コマンド実行時のタイマーを基準として128Ticksカウント（＝1秒）のウエイト期間中にキー入力があれば最後に押されたキーコードが返ります。
（例）Getkey3(128,A)
　Aをタイマーの初期値として現在のタイマー値が128Ticksカウント経つまでキー待ちをします。
（例）GetkeyM->List 1
 [EXE]と[F1]を同時押しした場合、 {79,31}が返ります。

※SH3機での入力が上手くいかない場合はGetkey1の代わりにGetkey2を使用してください。



===============================================================================
コマンドリファレンス　拡張グラフィックコマンド
===============================================================================
===============================================================================
テキスト系、グラフィック系表示コマンドにおいて
コマンドの直後に[＠]を加えるとテキストモードおよびグラフィックモードに関係なく現在のVRAMが描画対象となります。
-------------------------------------------------------------------------------
（例）Locate 2,2,"String"
　　　Text @16,1,"TextString"
　Textコマンドは現在のVRAM（＝テキストVRAM）に描画します。

-------------------------------------------------------------------------------
コマンド後の区切りが[：]コロンの場合は画面更新を抑制します。
描画結果をLCD表示させるにはPutoDispDD等の転送コマンドを使用して下さい。
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
Line,FLine,Vertical,Horizontal,Circle,Rect,FillRect
-------------------------------------------------------------------------------
コマンドの末尾に[,C]を加えると消去します。[,X]で反転します。
　（例）FLine 1,1,30,20,X


-------------------------------------------------------------------------------
Text
-------------------------------------------------------------------------------
（説明）　コマンドの最後に[,R]で反転表示、[,O]でOr表示、[,V]で反転Or表示が出来ます。
　[.N] Normal
　[.R] Reverse
　[,O] Or
　[,V] reVerse or
（例）Text 20,80,"Test",R
　　"Test"がグラフィック座標(80,20)に反転表示で表示されます。

-------------------------------------------------------------------------------
LocateYX
-------------------------------------------------------------------------------
（説明）グラフィック画面にLocateと同じサイズの文字表示が出来ます。
　　　　座標指定はTextコマンドと同じくY座標が先になります。
　　　　コマンドの最後に[,R]で反転表示となります。
（例）LocateYX 20,80,"Test",R
　　"Test"がグラフィック座標(80,20)に反転表示で表示されます。

-------------------------------------------------------------------------------
Rect
-------------------------------------------------------------------------------
（説明）矩形を表示します。座標は実座標指定となります。
（例）Rect 1,1,127,63
　　画面いっぱいに枠を描きます。

-------------------------------------------------------------------------------
FillRect
-------------------------------------------------------------------------------
（説明）塗りつぶした矩形を表示します。
（例）FillRect 1,1,127,63
　　画面を塗り潰します。

-------------------------------------------------------------------------------
ReadGraph(
-------------------------------------------------------------------------------
（説明）グラフィック画面のビットマップデータをビット単位で読み取ります。
（書式）ReadGraph(px1,py1,px2,py2)→Mat A
　　グラフィック画面の(px1,py1)-(px2,py2)の範囲をMat A行列に取り込みます。
　　行列は事前に確保しておく必要はありません。自動的に適切な行列サイズで確保します。
　　行列の型指定が無い場合は１ビット型になります。
　　WriteGraphコマンドでそのまま使えるデータとなります。

-------------------------------------------------------------------------------
WriteGraph(
-------------------------------------------------------------------------------
（説明）ビットマップデータを表示します。
　　　　ビットマップデータは予めMat行列に入力しておきます。
（書式１）WriteGraph x,y,dx,dy,Mat A ,P1[,P2]
　　グラフィック画面の座標(x,y)より幅dx、高さdyの範囲にMat Aのデータを描画します。
　　P1はデータの表示前加工指定で[,N]でそのまま加工無し、[,R]で反転、[,M]でメッシュ加工、
　　P2は指定無しでオーバーライト表示、[,A]でAnd表示、[,O]でOr表示、[,X]でXor表示となります。
（例）[[1,2,4,8,16,32,64,128]]→Mat A
　　WriteGraph 80,20, 8,8, Mat A, N
　　グラフィック画面の座標(80,20)より斜めの線[/]が描画されます。

（書式２）WriteGraph x,y,dx,dy,Mat A[m,n] ,P1[,P2]
　　グラフィック画面の座標(x,y)より幅dx、高さdyの範囲にMat Aの[m,n]からのデータを描画します。
（例）[[16,32,64,128][128,64,32,16]]→Mat A
　　WriteGraph 80,20, 4,4, Mat A[1,1], N
　　WriteGraph 80,24, 4,4, Mat A[2,1], N
　　グラフィック画面の座標(80,20)より[<]の図形が描画されます。

　　WriteGraph 80,20, 4,8, Mat A, N
　　でも同じ結果となります。

　ビットマップデータは8ビット単位で左上が基準になります。


-------------------------------------------------------------------------------
DotGet(
-------------------------------------------------------------------------------
（例）DotGet( px1,py1, px2,py2)→Mat A[x,y]
　　画面上の(px1,py1)-(px2,py2)の範囲をMat A[x,y]を始点として取り込みます。
　　指定範囲よりも行列が足りない場合は行列サイズまで取り込みます。

-------------------------------------------------------------------------------
DotPut(
-------------------------------------------------------------------------------
（例）DotPut( Mat A, x,y, px1,py1, px2,py2)
　　Mat A行列の(x,y)の要素を始点として、画面上の(px1,py1)-(px2,py2)の範囲に点を打ちます。

（例）DotPut( Mat A[x,y], x1,y1, x2,y2)→Mat B
　　Mat A行列の[x,y]を始点として、Mat Bの[x1,y1]-[x2,y2]の範囲にコピーします。
　　Mat Bがコピー範囲が収まる広さを確保していない場合は、Mat Bに収まる範囲でコピーします。
　　グラフィック画面への転送は行いません。

（例）DotPut( Mat A[x,y], x1,y1, x2,y2)
　　Mat A行列の(x,y)の要素を始点として、画面上の(px1,py1)-(px2,py2)の範囲に点を打ちます。

-------------------------------------------------------------------------------
DotTrim(
-------------------------------------------------------------------------------
（例）DotTrim(Mat A, x1,y1,x2,y2)→Mat B
	Mat行列内の[X1,y1]-[x2,y2]範囲の0ではないデータの矩形領域をトリミングしてMat B行列にコピーします。
	コピーする行列が確保されてない場合は新たに確保されます。
（例）DotTrim(px1,py1,px2,py2)→Mat A
	グラフィック画面からトリミング入力、
	グラフィックの(px1,py1)-(px2,py2)の範囲のドットが打たれている矩形領域をMat A行列にコピーします。
どちらの場合も、矩形領域サイズ（Mat行列の確保サイズ）はX,Y変数に自動的に入ります。
0ではないデータの矩形領域の右上X,Y座標は小文字変数x,yに自動的に入ります。

-------------------------------------------------------------------------------
CellSum(
-------------------------------------------------------------------------------
（説明）ライフゲーム専用コマンドです。
（例）CellSum(Mat B[X,Y])→C
　　Mat B[X,Y]周辺8ドットの合計値を計算します。

-------------------------------------------------------------------------------
DotLife(
-------------------------------------------------------------------------------
（説明）ライフゲーム専用コマンドです。
（例）DotLife( Mat A, x1,y1,x2,y2)→Mat B
　Mat Aの座標(x1,y1)-(x2,y2)の範囲をライフゲーム演算してMat Bに格納します。
　Mat AとMat Bは同じサイズの行列である必要があります。
　コマンド実行後に(x1,y1)-(x2,y2)の範囲よりもセルが広がった場合、その矩形範囲より±1の座標が整数変数に自動的に入ります。
　整数変数L : 左端座標-1
　整数変数R : 右端座標+1
　整数変数T : 上端座標-1
　整数変数B : 下端座標+1




===============================================================================
コマンドリファレンス　拡張その他コマンド
===============================================================================
-------------------------------------------------------------------------------
KeyRow(
-------------------------------------------------------------------------------
（説明）キーマトリクスのキースキャン結果を返します。

　　　　返り値対応ビット（2進数）
　    　 bit6  bit5 bit4 bit3 bit2 bit1
　 Row--------------------------------------Row
　　09　  F1    F2   F3   F4   F5   F6       09
　　08　  SHIFT OPTN VARS MENU ←  ↑        08
　　07　  ALPHA ^2   ^    EXIT ↓   →       07
　　06　  XTT   log  ln   sin  cos  tan      06
　　05　  ab/c  F<>D  (    )    ,   →       05
　　04　  7     8    9    DEL                04
　　03　  4     5    6    x    div           03
　　02　  1     2    3    +    -             02
　　01　  0     .    EXP  (-)  EXE           01
　 Row--------------------------------------Row

（例）KeyRow(9)
　　F4とF6を同時に押した場合は、bit3とbit1が1になり、返り値としては
　　2^3 + 2^1 = 10 が返ります。

-------------------------------------------------------------------------------
Ticks
-------------------------------------------------------------------------------
（説明）1/128sのタイマー変数です。
（例）0→Ticks
  内部タイマーを初期化します。
　内部タイマーは1/128s毎にカウントアップされる32ビットカウンタで、24時間で元に戻ります。
  最大値は24×60×60×128 -1 = 11059199となります。

-------------------------------------------------------------------------------
TicksWait
-------------------------------------------------------------------------------
（説明）1/128s単位で時間待ちをします。
　（TicksとWaitコマンドの連続合わせ技です。）
（例）TicksWait 128
　1秒間待ちます。
（例）TicksWait -128
　前回のTicksWaitコマンド実行時より1秒間待ちます。すでに1秒を越えていた場合は待ち時間無しで次の処理に移ります。
（例）TicksWait -4
　前回のTicksWaitコマンド実行時より4/128秒待ちます。ループ内にこのコマンドを一つ記述するだけで毎秒32回のループが作れます。

-------------------------------------------------------------------------------
DATE,TIME
-------------------------------------------------------------------------------
（説明）内蔵RTCの設定、読み出しを行います。文字列型の変数です。
（例）"2017/01/17"→DATE
（例）DATE
　2017/01/17 TUE
　と表示されます。曜日は自動計算されます。

（例）"23:59:59"→TIME
（例）TIME
　23:59:59
　と表示されます。

-------------------------------------------------------------------------------
Disp
-------------------------------------------------------------------------------
（説明）一時停止コマンド▲(Disps)と違い一時停止しない結果表示コマンドです。
　　　　結果表示ごとに一行スクロールします。
（書式）Disp 式
（例）Disp A+B

-------------------------------------------------------------------------------
BackLight
-------------------------------------------------------------------------------
（説明）バックライトコマンドの設定、状態を読み出します。バックライト装備のfx-9860GIIのみ対応となります。
（書式）Backlight n
　n=0　バックライト消灯
　n=1　バックライト点灯
　n=2　バックライト反転
（書式）+Backlight
　現在のバックライトの状態を返します。
　式の先頭にBacklightが来る場合はエラーになります。

-------------------------------------------------------------------------------
RefrshCtrl/RefrshTime
-------------------------------------------------------------------------------
・画面のリフレッシュをコマンドで設定できるRefrshCtrlとRefrshTimeコマンドを追加しました。
（書式）RefrshCtrl 式
（書式）RefrshTime 式

（例）RefrshCtrl 0
　リフレッシュコントロール無し。Off
（例）RefrshCtrl 1
　リフレッシュコントロール有り。Grpモードに設定します。
（例）RefrshCtrl 2
　すべてのリフレッシュコントロール有り。Allモードに設定します。

（例）RefrshTime 5
　リフレッシュコントール時間を5に設定します。

式の中で使うとRefreshCtrlとRefrshTimeコマンドを使うと現在の値を返します。
（例）+RefrshCtrl
　現在のリフレッシュコントロー値を返します。
　式の先頭にRefreshCtrlが来る場合はエラーになります。

-------------------------------------------------------------------------------
Screen
-------------------------------------------------------------------------------
（説明）VRAMアクセス時の対象VRAMを選択し、画面モードを変更します。
（書式1）Screen
　テキスト/グラフィックの切り替えをします。
（書式2）Screen.T またはScreen.t
　テキストVRAMに切り替え、画面モードをテキストモードに変更し、
（書式3）Screen.G またはScreen.g
　グラフィックVRAMに切り替えます。
（書式4）Screen 式
　式の値が0の場合はテキストモード、1の場合はグラフィックモードに切り替えます。

式の中でScreenコマンドを使うとテキストVRAMの場合は0，グラフィックVRAMでは１が返ります。
（例）+Screen
　式の先頭にScreenが来る場合はエラーになります。

-------------------------------------------------------------------------------
PutDispDD
-------------------------------------------------------------------------------
（説明）強制的に画面更新をします。
（書式1）PutDispDD

-------------------------------------------------------------------------------
PopUpWin
-------------------------------------------------------------------------------
（説明）現在のVRAMにポップアップウインドウ枠を描画します。
（書式）PopUpWin 行数（1から5まで）
（例）PopUpWin 3

-------------------------------------------------------------------------------
FkeyMenu(
-------------------------------------------------------------------------------
（説明）現在のVRAMがグラフィック画面の場合はグラフィック画面に、
	現在のVRAMがテキスト画面の場合にはテキスト画面にファンクションメニューを表示、消去します。
（書式1）FkeyMenu( n,"文字列")
　現在のVRAMのファンクションnに文字列を表示します。n:1〜6
（書式2）FkeyMenu( n,"文字列",R)
　現在のVRAMのファンクションnに文字列を反転表示します。n:1〜6
（書式3）FkeyMenu( n,"",C)
　現在のVRAMのファンクションnを消去します。n:1〜6

-------------------------------------------------------------------------------
Save
Load(
-------------------------------------------------------------------------------
（説明）行列のデータを読み書きをします。
（例）Save "TEST",Mat A
（例）Load("TEST")→Mat A
　Mat A行列の内容を保存、読み込みます。
　ファイル名は8文字まで、拡張子を省略した場合は[.bin]となります。
　現状、アクセスできるのは行列データのみとなります。
　保存形式はヘッダ無し、内部バイナリーデータそのままのデータファイルとなります。

（例）Save "TEST",Mat A[5,1]
　Mat A[5,1]より最後まで保存します。
（例）Load("TEST",16)→Mat A[10,1]
　保存されたデータの16バイト目のデータからMat A[10,1]に読み込みます

-------------------------------------------------------------------------------
IsExist(
-------------------------------------------------------------------------------
（説明）指定されたファイルが存在しない場合は0が返り値となります。ファイルが存在する場合はファイルサイズが返り値となります。
（例）IsExist("/ABC/TEST")
　"/ABC/TEST.bin"が存在すればファイルサイズが、存在しなければ0となります。
　ファイル名は8文字まで、拡張子を省略した場合は[.bin]となります。


-------------------------------------------------------------------------------
Delete
-------------------------------------------------------------------------------
（説明）指定されたファイルを削除します。
（例）Delete "TEST.dat"
　"TEST.dat"が存在すれば削除します。
（例）Delete "TEST.dat",1
　削除前に確認します。"TEST.dat"が存在すれば削除します。
　ファイル名は8文字まで、拡張子を省略した場合は[.bin]となります。

-------------------------------------------------------------------------------
AriasVar
-------------------------------------------------------------------------------
（説明）既定の変数を違う変数名でもアクセスできます。
	このコマンドを使うことで最大10個までエイリアス変数を利用できます。
	置き換え使用可能な変数名は[CHAR]で選択できる一文字キャラクターのみです。
　　　　変数名、行列名ともに同時に変更されます。
	同一変数に違う変数名を割り当てた場合は、後に実行されたAliasVarコマンドの変数名が有効になります。
（書式）liasVar 置き換える前の変数名＝置き換え後の変数名（一文字キャラクター）
（例）AliasVar A＝α
　　　α+100→α
　　AliasVarコマンド実行後は、変数Aをαとして使用できます。
　　αの実体はAなので
　　A+100→Aと同じです。

-------------------------------------------------------------------------------
Wait
-------------------------------------------------------------------------------
（説明）一定のウエイトをかけてプログラムの実行スピードを遅くします。
（例）Wait 100
　ウエイト値に100を設定します。
　SH3機でもSH4機でも同じ程度の速度低下となっています。
　ウエイト値、10で約1/2，100前後で速度1/10になります。（速度低下の程度はプログラムによって異なります。）


-------------------------------------------------------------------------------
StrRepl(
-------------------------------------------------------------------------------
（説明）文字列を置換をします。
（書式）StrRepl(文字列, 検索文字列, 置換文字列 [,検索開始位置])
（例）StrRepl("Hello World","World","Earth") -> "Hello Earth"
（例）StrRepl("abcabc","ab","ff",3) = "abcffc"
（例）StrRepl("abcabc","ab","ff") = "ffcffc"

-------------------------------------------------------------------------------
StrChar(
-------------------------------------------------------------------------------
（説明）繰り返し文字列を返します。
（例）StrChar("ABC",5)
　文字列、"ABCABCABCABCABC"が得られます。

-------------------------------------------------------------------------------
StrCentr(
-------------------------------------------------------------------------------
（説明）文字列を真ん中に配置します。
（使い方）StrCenter("文字列",長さ[,"周辺を埋めるキャラクタ"])
（例） StrCenter("Test",8)
　文字列、"  Test  "が得られます。
（例） StrCenter("Test",8,"*")
　文字列、"**Test**"が得られます。

-------------------------------------------------------------------------------
Hex(
-------------------------------------------------------------------------------
（説明）16進数文字列に変換します。
（例）Hex(12345)->Str 1
　"3039"がStr 1に入ります。
　数値に戻すは、
（例） Exp("0X"+Str 1)->A

-------------------------------------------------------------------------------
Bin(
-------------------------------------------------------------------------------
（説明）2進数文字列に変換します。
（例）Bin(12345)->Str 1
　"11000000111001"がStr 1に入ります。
（例）Exp("0B"+Str 1)->A

-------------------------------------------------------------------------------
StrBase(
-------------------------------------------------------------------------------
（説明）任意の進数変換をします。
（書式) StrBase(　N進数文字列, 変換前の進数N, 変換後の進数M)
        進数の範囲は2〜64までです。
  　　　使用キャラクタは{ 0-9 A-Z a-z <theta><pi>}
	N進数の文字列からM進数の文字列に変換します。
（例） StrBase("579",15,12) -> "873"
  StrBase("100",13,10) -> "169"
  StrBase("123",16,3) -> "101210"
  StrBase("43981",10,16) -> "ABCD"
  StrBase("12A345AFZ",36,10) -> "2999794422815"
  StrBase("AZaz",62,10) -> "2520113"

-------------------------------------------------------------------------------
StoCapt/RclCapt
-------------------------------------------------------------------------------
（説明）Captureファイルをストレージメモリ上への読み書きします。最大99までのファイルが利用できます。
（例）StoCapt 20
（例）RclCapt 20

　関連してPictファイルのファイルサイズを2KBから1KBに半減しました。

-------------------------------------------------------------------------------
ListCmp(
-------------------------------------------------------------------------------
（説明）リスト同志を比較します。""を追加しました。
　リストとリスト、リストと値の比較ができます。
（例）ListCmp({1,2,3},{1,2,3})
 　1が返ります。
（例） ListCmp({1,2,3},{1,3})
 　0が返ります。
（例） ListCmp({1,2,3},{1,3,2})
 　0が返ります。
（例） ListCmp({1,2,3},2)
 　1が返ります。
（例） ListCmp({1,2,3},4)
 　0が返ります。



===============================================================================
コマンドリファレンス　拡張その他
===============================================================================

「’/」以降はコメントではなくコマンドとして実行します。
C.Basic動作時にのみ実行するコマンドを記述できます。

（例）'/Ticks→S
（例）'/Ticks-S→T
　時間を計測します。

===============================================================================



===============================================================================
コマンドリファレンス　マシン語関連コマンド
===============================================================================
C.Basicではメモリ上のSH3/SH4Aのマシン語プログラムを実行できます。
現状、自由にアクセス出来るメモリは行列として確保したエリアだけとなっています。
行列の先頭アドレスはVarPtr()もしくはアドレス演算子＆で求められます。
C言語同様にアドレス演算子＆、間接演算子＊も使えます。

-------------------------------------------------------------------------------
SysCall()
-------------------------------------------------------------------------------
（説明）OSで用意されているシステムルーチンを呼び出す関数です。引数は４つまでです。引数は省略できます。
（書式）SysCall( システムコール番号 [,引数1][,引数2][,引数3][,引数4] )

（例）Screen.G
　　　SysCall( 0x763,1,8,127,63 )→R

　システムコール0x763は画面に四角形を描画するシステムルーチンです。
　1→R4レジスタ、8→R5レジスタ、127→R6レジスタ、63→R7レジスタ、システムコール0x763を呼び出し返り値がRに入ります。

-------------------------------------------------------------------------------
Call()
-------------------------------------------------------------------------------
（説明）任意のアドレスのマシン語プログラムを実行する関数です。引数は４つまでです。引数は省略できます。
（書式）Call(マシン語アドレス [,引数1][,引数2][,引数3][,引数4] )

（例）Call( 0x8802F000,A,B,C,D )→R
　A→R4レジスタ、A→R5レジスタ、A→R6レジスタ、A→R7レジスタ、0x8802F000番地にあるマシン語プログラムを呼び出し返り値がRに入ります。

-------------------------------------------------------------------------------
Peek(
-------------------------------------------------------------------------------
（説明）メモリのデータを読み出す関数です。型指定[.B][.W][.L][.F]が無い場合はバイト読み出しです。
	間接演算子＊で置き換えることが出来ます。
（書式）Peek( アドレス )[.B][.W][.L][.F]
（書式）＊( アドレス )[.B][.W][.L][.F]

（例）Peek(0x8802E000).B→A%
（例）*(0x8802E000).B→A%
　0x8802E000番地の内容をバイト(1バイト)で読み出し、整数変数A％に代入します。

（例）Peek(0x8802E000).W→A%
（例）*(0x8802E000).W→A%
　0x8802E000番地の内容をワード(2バイト)で読み出し、整数変数A％に代入します。

（例）Peek(0x8802E000).L→A%
（例）*(0x8802E000).L→A%
　0x8802E000番地の内容をロングワード(4バイト)で読み出し、整数変数A％に代入します。

（例）Peek(0x8802E000).F→A
（例）*(0x8802E000).F→A
　0x8802E000番地の内容を倍精度実数(8バイト)で読み出し、変数Aに代入します。

-------------------------------------------------------------------------------
Poke(
-------------------------------------------------------------------------------
（説明）メモリにデータを書き込みます。型指定[.B][.W][.L][.F]が無い場合はバイト書き込みです。
	間接演算子＊で置き換えることが出来ます。
（書式1）Poke( アドレス )[.B][.W][.L][.F] , データ
（書式1）＊( アドレス )[.B][.W][.L][.F] , データ
（書式2）データ→Poke( アドレス )[.B][.W][.L][.F]
（書式2）データ→＊( アドレス )[.B][.W][.L][.F]

（例）Poke(0x8802E000).B,A%
（例）A%→Poke(0x8802E000).B
（例）A%→*(0x8802E000).B
　整数変数A％の値を、0x8802E000番地にバイト(1バイト)書き込みします。

（例）Poke(0x8802E000).W,A%
（例）A%→Poke(0x8802E000).W
（例）A%→*(0x8802E000).W
　整数変数A％の値を、0x8802E000番地にワード(2バイト)書き込みします。

（例）Poke(0x8802E000).L,A%
（例）A%→Poke(0x8802E000).L
（例）A%→*(0x8802E000).L
　整数変数A％の値を、0x8802E000番地にロングワード(4バイト)書き込みします。

（例）Poke(0x8802E000).F,A
 (例）A→Poke(0x8802E000).F
 (例）A→*(0x8802E000).F
　実数変数Aの値を、0x8802E000番地に倍精度実数(8バイト)書き込みします。

-------------------------------------------------------------------------------
VarPtr(
-------------------------------------------------------------------------------
（説明）変数、行列のアドレスを返す関数です。
	アドレス演算子＆で置き換えることが出来ます。
（書式1）VarPtr(変数)
（書式2）＆(変数)

（例）VarPtr(A%)
（例）&A%
　整数変数A％の変数のアドレスが返ります。

（例）VarPtr(Mat A)
（例）&Mat A
　行列Aの先頭アドレスが返ります。

（例）VarPtr(Mat A[20,10])
（例）&Mat A[20,10]
　行列A[20,10]の値が格納されているアドレスが返ります。

-------------------------------------------------------------------------------
ProgPtr()
-------------------------------------------------------------------------------
（説明）プログラムのアドレスを返す関数です。
（例）ProgPtr()
　現在のプログラムが格納されているアドレスを返します。



===============================================================================
コマンドリファレンス　超高速グラフィックライブラリコマンド MonochromeLib
===============================================================================
PierrotLL氏作成のグラフィックライブラリMonochromeLibに基づくコマンドです。
これらのコマンドは現在のVRAMに作用し、それ以外の処理を一切しません。
座標系は(0,0)-(127,63)固定です。
表示するためにはPutDispDDや_DispVRAMを使いLCD転送する必要があります。
C.Basicの拡張仕様を利用しているのでCasioBasic互換コマンドとは若干使い勝手が違います。

-------------------------------------------------------------------------------
_ClrVRAM
（説明）現在のVRAMを消去します。
-------------------------------------------------------------------------------
_ClrScreen
（説明）現在のLCD画面を消去します。
-------------------------------------------------------------------------------
_DispVRAM
（説明）現在のVRAMの内容をLCD画面に転送します。
-------------------------------------------------------------------------------
_Pixel
（説明）VRAMに点を描画します。
（書式）_Pixel X, Y, Color

 Color:-1 描画しません。
 Color: 0 白色で描画します。
 Color: 1 黒色で描画します。
 Color: 2 反転します。
 Color: 3 チェック模様で描画します。

（例）_Pixel 64, 32, 2
　画面中央の点を反転します。

-------------------------------------------------------------------------------
_Point
（説明）VRAMに四角形を描画します。
（書式）_Point X, Y, Width, Color
　(X,Y)を中心にWidth幅の四角形を描画します。

（例）_Point 10, 10, 3, 1
 Rect 9,9,11,11と同じです。

-------------------------------------------------------------------------------
_PixelTest(
（説明）VRAMの一点の状態を返します。
（書式）_PixelTest(X,Y）

 返り値
 -1 ：範囲外
  0 ：白色
  1 ：黒色

-------------------------------------------------------------------------------
_Line
（説明）VRAMにラインを描画します。
（書式）_Line X1, Y1, X2, Y2, Color

-------------------------------------------------------------------------------
_Horizontal
（説明）VRAMに水平線を描画します。
（書式）_Horizontal Y, X1, X2, Color
　X1〜X2の範囲のYラインを描画します。

-------------------------------------------------------------------------------
_Vertical
（説明）VRAMに垂直線を描画します。
（書式）_Vertical X, Y1, Y2, Color
　Y1〜Y2の範囲のXラインを描画します。

-------------------------------------------------------------------------------
_Rectangle
（説明）VRAMに四角を描画します。
（書式）_Rectangle X1, Y1, X2, Y2, border_width, border_color, Color
　(X1,Y1)-(X2,Y2)の範囲で、境界幅border_widthの枠を境界色border_colorで描画し、四角の内側をColorで塗りつぶします。

（書式）_Rectangle 50, 20, 80, 40, 2, 1, -1
　画面中央に幅２ドットの四角枠を描画します。
（書式）_Rectangle 50, 20, 80, 40, 0, -1, 3
　画面中央にチェッカー模様の四角を描画します。

-------------------------------------------------------------------------------
_Polygon
（説明）VRAMに多角形を描画します。
（書式）_Polygon X座標のint行列へのポインタ, Y座標のint行列へのポインタ, 頂点数, Color

（例）
　[[60, 75, 70, 50, 45]]→Mat X.L	// 整数型指定必須
  [[20, 30, 45, 45, 30]]→Mat Y.L	// 整数型指定必須
  Screen.G
  _ClrVRAM
  _Polygon VarPtr(Mat X), VarPtr(Mat Y), 5, 1);　（または　_Polygon &Mat X, &Mat Y, 5, 1);
  _DispVRAM （またはPutDispDD）

　画面に五角形を描画します。

-------------------------------------------------------------------------------
_FillPolygon
（説明）VRAMに多角形を描画し中を塗りつぶします。
（書式）_FillPolygon X座標のint行列へのポインタ, Y座標のint行列へのポインタ, 頂点数, Color

-------------------------------------------------------------------------------
_Circle
（説明）VRAMに円を描画します。
（書式）_Circle X, Y, R, Color
　(X,Y)を中心に半径Rの円を描画します。

-------------------------------------------------------------------------------
_FillCircle
（説明）VRAMに円を描画し中を塗りつぶします。
（書式）_FillCircle X, Y, R, Color
　(X,Y)を中心に半径Rの円を描画し、Colorで塗りつぶします。

-------------------------------------------------------------------------------
_Elips
（説明）VRAMに楕円を描画します。
（書式）_Elips X, Y, Rwidth, Rheight, Color
　(X,Y)を中心に横罫Rwidth、縦径Rheightの楕円を描画します。

-------------------------------------------------------------------------------
_FillElips
（説明）VRAMに楕円を描画し中を塗りつぶします。
（書式）_FillElips X, Y, Rwidth, Rheight, Color
　(X,Y)を中心に横罫Rwidth、縦径Rheightの楕円を描画し、Colorで塗りつぶします。

-------------------------------------------------------------------------------
_ElipsInRct
（説明）VRAMに楕円を描画します。
（書式）_ElipsInRct X1, Y1, X2, Y2, Color
　(X1,Y1)-(X2,Y2)の範囲に内接する楕円を描画します。

-------------------------------------------------------------------------------
_FElipsInRct
（説明）VRAMに楕円を描画し中を塗りつぶします。
（書式）_FElipsInRct X1, Y1, X2, Y2, Color
　(X1,Y1)-(X2,Y2)の範囲に内接する楕円を描画し、Colorで塗りつぶします。

-------------------------------------------------------------------------------
_Hscroll
（説明）水平方向にスクロールします。
（書式）__Hscroll n
　nドット分スクロールします。
　+で右方向、-で左方向にスクロールします。溢れた分は反対側に出現します。

-------------------------------------------------------------------------------
_Vscroll
（説明）垂直方向にスクロールします。
（書式）__Vscroll n
　nドット分スクロールします。
　+で↓方向、-で上方向にスクロールします。溢れた分は反対側に出現します。

-------------------------------------------------------------------------------
_Bmp
（説明）VRAMにビットマップデータを描画します。
（書式）_Bmp ビットマップint行列へのポインタ, X, Y, width, height [,O/A/X] [,C]
　行列内のビットマップデータを、(X,Y)より横幅width　縦幅heightで描画します。
　[.O] Or
　[.A] And
　[,X] Xor
　[,C] クリッピングした後に描画します。
（例）
　[[60, 126, 251, 253, 253, 255, 126, 60]]→Mat B.B	//　バイト行列
　_Bmp VarPtr(Mat B), 8, 16, 4, 8, O, C


-------------------------------------------------------------------------------
_Bmp8
（説明）VRAMに8x8のビットマップデータを描画します。
（書式）_Bmp8 ビットマップint行列へのポインタ, X, Y [,O/A/X] [,C]
　行列内の8x8のビットマップデータを、(X,Y)に描画します。
（例）
　[[60, 126, 251, 253, 253, 255, 126, 60]]→Mat B.B	//　バイト行列
　_Bmp &Mat B, 8, 16, A

-------------------------------------------------------------------------------
_Bmp16
（説明）VRAMに16x16のビットマップデータを描画します。
（書式）_Bmp16 ビットマップint行列へのポインタ, X, Y [,O/A/X] [,C]
　行列内の16x16のビットマップデータを、(X,Y)に描画します。

-------------------------------------------------------------------------------
Monochromeライブラリ系コマンド追加機能
-------------------------------------------------------------------------------
・BMP形式の読み書きができます。（1ビット、モノクロのみ）
（例）BmpSave "TEST",Mat A
　行列AのデータをBMP形式で"TEST.bmp"に保存します。
（例）BmpLoad("TEST")->Mat A
　"TEST.bmp"のデータを行列Aに読み込みます。
-------------------------------------------------------------------------------
・DrawMatコマンドを追加しました。（DotPutコマンドのMLコマンド仕様です。）
 （書式）DrawMat Mat A[px,py], x, y, width, height [,横拡大幅][,縦拡大幅][,color][,確率]
 （例） DrawMat Mat A, 0, 0, 128, 64
 （例） DrawMat Mat A[10,5], 0, 0, 40, 30, %150, %250 , 4, %50
-------------------------------------------------------------------------------
・Monochromeライブラリ系コマンドの"_Circle"コマンドに角度指定と頂点指定を追加しました。
(書式)_Circle x,y,radius,color[,chance][,width][,角度初期値][,角度終了値][,頂点数]
（例） _Circle 64,32,20,4,0.5,3
 3x3dot 50% circle
（例） _Circle 64,32,20,1,,3,0,90
 to draw 3x3dot 1/4 circle
（例）_Circle 64,32,20,1,,,0,360,5
 to draw pentagon ( to have an effect on setting of Draw Type )
（例） _Circle 64,32,20,1,,,20,380,5
 to draw shifted pentagon
-------------------------------------------------------------------------------
・Monochromeライブラリ系コマンドに図形の内部の黒ドット数をカウントする"_Test"コマンドオプションを追加しました。
(サポートコマンド) _Point _Line _Rectangle _Circle _Polygon
　サポートコマンドの前に"_Test"を付けると機能します。
（例）_Test_Rectangle 0,0,127,63
　(0,0)-(127,63)エリアにおける黒ドットの数を返します。
（例）_Test_Circle 62,32,20
（例）_Test_Point 10,10,5
（例）_Test_Line 10,10,100,30
-------------------------------------------------------------------------------
・Monochromeライブラリ系コマンドに拡大縮小、回転処理を加えてビットマップ表示する"_BmpZoom"と"_BmpRotate"と"_BmpZoomRotate"コマンドを追加しました。
（Planet-CasioよりNinestars氏がMonochromeライブラリに機能追加したプログラムを利用させて頂いています。）
（書式）_BmpZoom &Mat , x, y, width, height [,横拡大幅] [,縦拡大幅] [,color][,確率]
（書式）_BmpRotate &Mat , x, y, width, height, 回転角(度) [,color][,確率]
（書式）_BmpZoomRotate &Mat , x, y, width, height [,横拡大幅] [,縦拡大幅] [,回転角(度)] [,color][,確率]
（例）_BmpZoom &Mat A, 0, 0, 20, 10, 1.5, 2.5
（例）_BmpZoom &Mat A, 0, 0, 20, 10, %150, %250 , 4, %50
（例）_BmpRotate &Mat A, 0, 0, 20, 10, 45
（例）_BmpZoomRotate &Mat A, 0, 0, 20, 10, 1.5, 2.5, 90
（例）_BmpZoomRotate &Mat A, 0, 0, 20, 10, %150, %250 , 15, 4, %50

-------------------------------------------------------------------------------
・Monochromeライブラリ系コマンドの描画色に2x2ドット柄を追加しました。
　Colorの値:10      11　　　12　　　13　　　14 （1ドット描画）
　Colorの値:20　　　21　　　22　　　23　　　24 （2x2ドット描画)
　　　　　　□□　　■□　　■□　　■■　　■■
　　　　　　□□    □□    □■    ■□    ■■
（例）_FillCircle 64,32,30,21

・Monochromeライブラリ系コマンドの描画色にランダムカラーを追加しました。
　Colorの値に４を指定した場合、Colorに続くパラメータは黒ドットとなる確率(0〜1)を指定できます。
（例） _Rectangle 0,0,127,63,0,0,4,0.5
　画面全体が半分の確率でランダムに黒ドットで埋まります。
（例） _Rectangle 0,0,127,63,0,0,4,0.1
　画面全体が10％の確率でランダムに黒ドットで埋まります。
（例）_FillCircle 64,32,30,4,0.5
 　円の内側が50％の確率で黒ドットで埋められます。
（例） _FillCircle #0,0,3,4,0.5
　円の内側が半分の確率でランダムに黒ドットで埋まります。
-------------------------------------------------------------------------------
・Monochromeライブラリ系コマンドの"_Line"コマンドにおいて線の太さ指定を追加しました。
（書式）_Line x1,y1,x2,y2,color[,確率][,幅]
（例）_Line 0,0,127,63,1,,10
　画面を斜めに10ドットの太さの直線が描かれます。
-------------------------------------------------------------------------------
・Screenコマンドに画面全体を反転するRオプションを追加しました。"Screen"+"R"
（例）ScreenR

・論理座標系から物理座標を求めるScreenコマンドの"#"オプションを追加しました。
　結果はListAnsに返ります。
（使い方) Screen#X,Y[,Xmin][,Xmax][,Ymin][,Ymax]
（例)Screen#1,1,-6.3,6.3,-3.1,3.1
　　ListAns{74,22}
・物理座標系から論理座標を求めるScreenコマンドの"%"オプションを追加しました。
　結果はListAnsに返ります。
（使い方) Screen%X,Y[,Xmin][,Xmax][,Ymin][,Ymax]
（例)Screen%74,22,-6.3,6.3,-3.1,3.1
　　ListAns{1,1}
-------------------------------------------------------------------------------
・Monochromeライブラリ系のコマンドを論理座標で使うことのできる"#"オプションを追加しました。
  support ML command,
	_Point
	_Pixel
	_PixelTest(
	_Line
	_Rect
	_Horizontal
	_Vertical
	_Circle
	_FillCircle
	_Elips
	_FillElips
	_ElipsInRct
	_FElipsInRct

(例) ViewWindow -6.3,6.3,0,-3.1,3.1,0
 Screen.G
_Circle #0.5,1.2,1.2.1


===============================================================================
セットアップでの設定
===============================================================================
Draw Type   :Connect/Plot
Coord       :on/off
Grid        :on/off
Axes        :on/off
Label       :on/off
Derivative  :on/off
Background  :None/Pict1〜20
Sketch Line :Normal/Thick/Broken/Dot
Angle       :Rad/Deg/Grad
----------------------------ここまで純正CasioBasic互換

-------------------------------------------------------------------------------
Display     :Fix/Sci/Nrm/Eng
                少数以下の桁数は15桁まで。0を指定した場合は16桁となります。
                Nrmに関してはNrm1とNrm2のみCasioBasic互換10桁表示仕様です。
                Nrm1：0.01以下は指数表示
                Nrm2：0.000000001以下は指数表示
                それ以外は桁数指定となります。
		Eng ：ENGオフ、ENGオン(/E)、3桁区切り(/3)の切り替えとなります。

・関連コマンド	Eng,Norm,Fix,Sci,EngOn,EngOff

-------------------------------------------------------------------------------
Command Input :C.Basic/Standard
		コマンド入力方法をC.Basic(fx-5800P)方式とStandard(fx-9860G)方式を選択できます。

-------------------------------------------------------------------------------
Edit TopLine  :On/Off
		画面の最上位一行目をエディタで使用するかどうか選択できます。

-------------------------------------------------------------------------------
EditFontSize  :Standard/Mini/MiniRev/Mini(undercursor)/MiniRev(undercursor)
		表示文字の大きさを変更します。

-------------------------------------------------------------------------------
Edit LineNum  :On/Off
		行番号表示を選択します。

-------------------------------------------------------------------------------
EditListChar  :List / 反転L / ボールドL
		ListとMat表示を短縮表示（1文字の反転とボールド）に切り替えます。
-------------------------------------------------------------------------------
Use Hidden RAM :on/off
		隠しRAMをC.Basicで使用するかどうかを設定します。（初期のfx-9860Gは未対応です。）
		fx-9860GII以降では512KBのRAMが搭載されており、そのうち256KBは未使用領域となっているためにこれをプログラム領域と行列領域として利用できるようにします。

-------------------------------------------------------------------------------
HiddenRAM　Init:on/off
		隠しRAM使用時に、Mat行列&ListをC.Basic起動時に初期化するかどうかを設定します。（初期のfx-9860Gは未対応です。）
		初期化しない場合は、Mat行列&Listの結果が消えないで残ります。

-------------------------------------------------------------------------------
Max Pict No  : 20 〜99
		隠しRAM使用時に、Pictファイルの上限を増やせます。
		設定を変更するとPict＆Mat＆Listデータが初期化されます。

-------------------------------------------------------------------------------
Max List No  : 54 〜1040
		隠しRAM使用時に、Listの上限を増やせます。
		設定を変更するとPict＆Mat＆Listデータが初期化されます。

-------------------------------------------------------------------------------
AT DebugMode  : on / off
		[AC]で中断した時にデバッグモードの有効/無効を設定します

-------------------------------------------------------------------------------
Break Stop  :on/off
		[AC]キーによる中断の有無。
		offの場合は[AC]キーによる中断が出来ません。

-------------------------------------------------------------------------------
Exec TimeDsp:on/off
		プログラム終了時にプログラムの実行時間を表示します。
		計測開始はプログラムの最初の行からですが、途中？コマンドや一時停止コマンドがあった場合はそれまでの計測時間はリセットされます。

-------------------------------------------------------------------------------
IfEnd Check :on/off
		IfとIfEndが一対一で対応しているかどうかをチェックします。

-------------------------------------------------------------------------------
ACBreak     :on/off
		ACBreakコマンドの有効/無効を切り替えます。

・関連コマンド	ACBreak

-------------------------------------------------------------------------------
Force Return: None/ F1/ EXE/ F1&EXE
		プログラム実行中の中断でエディタに戻るかファイルリストに戻るかを選択できます。

-------------------------------------------------------------------------------
Key 1st time:25ms〜1000ms(デフォルト値 500ms)
		リピート開始までの時間 (25ms単位)
Key Rep time:25ms〜500ms(デフォルト値 125ms)
		リピート継続時間 (25ms単位)

-------------------------------------------------------------------------------
SkipUp/Down : 1〜9999
		SkipUp/SkipDownでの一回分の改ページ数を指定します。
		※改行ごとに一行増える論理行ではなく画面上での見た目上での物理行数です。

-------------------------------------------------------------------------------
Mat Dsp mode:[m,n]/[X,Y]
		行列エディタ画面での表示形式を指定します。
		それぞれ転置行列の関係になりますが、行列内部は何も変化なく表示上だけの指定です。
Matrix base :0/1
		行列インデックスの初期値を0か1が指定します。
		初期値に0を指定した場合は、グラフィック座標が左上端の(0,0)から有効になります。

・関連コマンド	'#Mat 0
		'#Mat 1

-------------------------------------------------------------------------------
Pict mode   :S.Mem/Heap/Both
		(S.Mem/SD)　Pictファイルをストレージメモリ/SD上に作ります。若干時間がかかります。
		(Heap)　Pictファイルとしては作成されずにメモリ上に互換ファイルが作成されます。
		(Both)　HeapモードでもPictファイルが常にストレージメモリ/SD上に作成されます。

-------------------------------------------------------------------------------
DATE : 2017/01/17 MON
TIME : 23:59:59
		内蔵RTCを設定します。曜日は自動設定されます。

・関連コマンド	DATE、TIME

-------------------------------------------------------------------------------
Storage mode :S.Mem/SD
		(S.Mem)　ストレージメモリ上のファイルを実行/編集します。
		(SD)　SD上のファイルを実行/編集します。（SD版のみ指定可）

-------------------------------------------------------------------------------
Auto file Save:on/off
		編集後、自動的に保存するかどうか設定します。

-------------------------------------------------------------------------------
Force g1m save:on/off
		テキストファイル編集／実行後に同時にg1m形式でも保存するかどうかを設定します。

-------------------------------------------------------------------------------
RefrshCtl DD:off/Grp/All
		描画コマンドにおける画面の更新を設定できます。
		Off：リフレッシュコントロール無し。表示においては純正互換仕様です。
		Grp：グラフィックコマンドのみリフレッシュコントロール有り。ClrText,Locate,Text,LocateYX、””は無しで以前のバージョン互換です。
		All：すべての描画コマンドがリフレッシュコントロールされた表示となります。必要に応じてPutDispDDコマンドが必須となります。
		Time：リフレッシュコントール時間を設定します。n/128秒単位で画面更新します。デフォルトは3で約1/42秒での更新となっています。
		　　　0を指定するとリフレッシュされなくなります。

・関連コマンド	RefrshCtrl/RefrshTime

-------------------------------------------------------------------------------
Wait count : 0〜9999
		C.Basic全体の実行速度を調整します。

・関連コマンド	Wait

-------------------------------------------------------------------------------
Execute mode:Dbl#/Int%
		デフォルトのプログラムの実行モードを切り替えます。

・関連コマンド	'#CBasic
		'#CBASIC
		'#CBDBL
		'#CBdbl
		'#CBINT
		'#CBint

===============================================================================

