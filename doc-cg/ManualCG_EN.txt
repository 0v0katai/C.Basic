===============================================================================
Preface
===============================================================================
Please look at this site: https://egadget2.web.fc2.com/CBasic/Interpreter/CBasic_interpreter.html
This site and the following text is translated by Krtyski.
Some following text is translated by sentaro21.
(Borrow the power of the automatic translation)

Sorry that translation is not good...
(Thanks to Emex for correcting the spellings)

Grammars and typos in the manual are checked and corrected by CalcLoverHK. Some parts of descriptions are improved by CalcLoverHK.

If you found some errors or bad expressions in the manual, please tell us in Universal Casio Forum (recommended) or Planete-Casio. We are very appreciate of your contributions.

If there is any conflict or inconsistency between English, Japanese and French versions, the English version shall prevail.

-------------------------------------------------------------------------------
Add-in Version Casio Basic Interpreter (& Compiler) for CG Series Comprehensive Manual
-------------------------------------------------------------------------------
Copyright © 2015-2017-2020 by sentaro21.
Contact: (E-mail) sentaro21@pm.matrix.jp

Last updated by CalcLoverHK/sentaro21 - 9 Feb 2020
(Updated to version 1.45 beta)

===============================================================================
What is C.Basic for CG?
===============================================================================
C.Basic for CG is designed for fast, compatible with genuine Casio Basic and also bringing in some of good features of fx-5800P and C programming language.
C.Basic uses program file (*.g1m / *.g3m) stored in storage memory as same as genuine Casio Basic.
A program using only compatible commands can run in both of C.Basic and genuine Casio Basic.

=============================================================================== (Extended for CG)
Execution modes - g1m/g3m
===============================================================================
C.Basic has g1m mode which is compatible with the FX version and g3m mode corresponding to the CG series.

When you operate g1m program with g3m mode, C.Basic is compatible with the text commands, but not some part of graphing commands.

=============================================================================== (Extended for CG)
Available memory
===============================================================================
There are 128KB of RAM that can be freely used as add-in.
There is free RAM of 6MB in CG50 for C.Basic to use.
(Hidden memory setting is in setup)

===============================================================================
Editable size in built-in editor
===============================================================================
C.Basic has built-in editor aiming for usability similar to standard editor.
Copy and paste can be used, but 16KB is the maximum size that can be copied at once. Undo is not implemented yet.

The initial editable size of the new file is 32KB.
If you exceed the limit when creating the program, you cannot edit it. Please save it once and re-edit.
The program editable maximum size at the time of re-editing is program size + 8KB.

When executing a program, the main program is executed with securing an editable area of main program size + 8KB and subprogram + 512B.
It becomes re-editable size in debug mode.

The program editable maximum size is about 62KB.

===============================================================================
Built-in debug mode
===============================================================================
As a function that is not genuine, resumption of the program interrupted by [AC], and debug mode are equipped.
Debug mode can also be started in debug mode from the first run.
Trace execution, 1 step execution, step over, step out are supported.

===============================================================================
Operation modes - "Integer", "Real" mode and "Complex" mode
===============================================================================
C.Basic supports three different operation modes:
"Real (Number) Mode": normal calculations (same as genuine Casio Basic)
"Complex Mode": complex calculations (same as genuine Casio Basic)
"Integer Mode": only integer calculations

The "Integer Mode" is implemented to C.Basic for faster operation.

In order to set either of those running modes, to set "Real Mode" declare one of followings:
'#CBasic
'#CBASIC
'#CBdbl
'#CBDBL

To set "Integer Mode" declare one of followings:
'#CBint
'#CBINT

To set "Complex Mode" declare one of followings:
'#CBcplx
'#CBCPLX

In C.Basic real number is implemented in double-precision real type, so real and double-precision is the same.
You can set default settings in Setup page. To set default running mode, set "Execute mode" as Dbl# or "Int%".

The declared running mode in source file has priority to setting in the Setup page.

In "Integer Mode", result value of calculation have to be given in integer, but the operation speed is 50% faster than in "Real Number Mode".

If you set "Integer Mode" but want to evaluate a specific expression in real number (double-precision), simply add prefix # before the expression you want.
The expression after # is evaluated in double-precision without error.
However, please note that the evaluation result in double-precision is converted to integer, so the expression after # will return value in integer by rounding to integer to fit the "Integer Mode".

(Example)
"100*Frac 1.23+5

In "Integer Mode", Frac 1.23 is in error and the following codes cannot run, but the prefix # enable evaluation in double-precision of expression after # to end of line or ":" (multi-statement command).
#(Frac 1.23*100+5)

Therefore, the result of this line is 28. If this code runs in "Real More", it also results in 28.

If # is in middle of expression, a part of the expression after # to end of line or multi-statement command.

(Example)
100*#Frac 1.23+5

Interpretation of this expression is
100*#(Frac 1.23+5)
So it results in 523 in "Real Mode" and 500 in "Integer Mode".

===============================================================================
Wait command
===============================================================================
You can adjust the overall execution speed.
If it is set in setup, all programs will be affected.

Use the Wait command if you want to adjust with individual programs.
(Example) Wait 100
Set the Wait value to 100.

===============================================================================
Type of Numbers
===============================================================================
Genuine Casio Basic use decimal number with internally 15 digits and 2 digits of exponent notation. On the other hand, C.Basic basically use a double precision real number type (8 Bytes) and 4 Bytes integer type, since Casio SDK (written in C language) has the same specification.
A range of number that the double precision real number can handle is
+-9.88131291682493e-323 to +-1.7976931348623151e+308
This range is wider than genuine Casio Basic, but operation is carried out in binary, so we have to keep in mind that handling of number after decimal point may cause possible calculation error.

We can put prefix 0X or 0B like C language to value of constant and then we can use hexadecimal or binary number within 32 bits.
(Example) 0XFF, 0B10100110
(Example) 0xAB, 0b10100110

===============================================================================
Type of Variables
===============================================================================
As well as genuine Casio Basic, C.Basic uses single letter variables, 26 capital letters A to Z and also small letters a to z.

String variable with more than 2 letters is not supported by C.Basic as well as genuine Casio Basic.

C.Basic provides independently real number type of variables (A - Z, a - z) and integer type of variables (A - Z, a - z).
Real number variables are used in real number running mode and also integer variables in integer running mode.
In general, the different type of variable still use same letter, so we should put % suffix for integer variables (A% - Z%, a% - z%), put # suffix for real number variables (A# - Z#, a# - z#).

When an integer variable with % suffix is used in real number mode it won't be a problem. But on the other hand, if a real number variable is used in integer mode, we have to understand that read-out value from the real number variable is rounded integer.
When real number value does not fit in the range of integer number, the value is changed to 0 (zero).

(Example) #CBINT // set to integer mode
          #1.2345->A# // 1.2345 is rounded to 1 then substituted.

(Example)   A%->A#
Copy integer variable A to double-precision variable A.
Copying integer value to double-precision variable is no problem. But double-precision value is going to be contained into integer variable, this may have a problem, in case the value does not fit into a range of integer (32 bits) the value is changed to 0.

At initialization of variable, we can use a Format 0->A ~ Z (genuine Casio Basic can do this) and also we van set type of variable.
0->A#~Z# // initialize double-precision variable
0->A%~Z% // initialize integer variable

===============================================================================
Extended Variable
(0.35 -)
===============================================================================
The variable by an alphanumeric character’s name beginning with under bar (to 8 characters) is usable.
It is always initialized at the time of program starts with the variable of the area independent of the conventional one character variable.
The usable variable becomes to 99. The real number variable and the integer variable can maintain a different value, but are found by the same name.
[SHIFT]+[F1] the capital letter variable, the small letter variable, the indication of the under bar variable are replaced whenever to push [F1].

(Example) 123.456->_ABC
(Example) 456->_ABC%
(Example) _ABC+_ABC%->_Result
 _Result is 579.456

===============================================================================
The constant number use of the variable
(0.35-)
===============================================================================
To use Const command with a variable as constant number use-limited.   [OPTN] -[F3](extd) -[F3](Const)
Since then cannot substitute it when to use Const command at the time of variable substitution.
(Example) 123->Const A
(Example) 123->Const _ABC
(Example) 456->A
If you are going to change the value of the variable by the same program, it becomes the error.

=============================================================================== (Extended for CG)
Screen size
===============================================================================
The range that can be used is 384x216 dot in the CG series normally.
The range that can paint pictures in genuine Casio Basic is 384x192 except the upper status line, but supports all 384x216 with the C.Basic for CG as a drawing range.
384x192 range applied by the command is compatible with genuine Casio Basic, but as for some commands, the status line becomes targeted for drawing, too.

(Example) Locate 1,0,"STATUS LINE"
(Example) Text -24,1,"STATUS LINE"
 Display "STATUS LINE" on the status line.

=============================================================================== (Extended for CG)
Extended color display
===============================================================================
Normally in genuine Casio Basic, there are only 16 variants of colors (8 colors * 2 types of transparency) that can be used in the CG series.
Actually, the CG series calculators adopted the 16-bit color depth, which means there are total 65536 (2^16) possible colors. C.Basic can show all 65536 colors.
C.Basic supports 24-bit color depth input, but because of the limitations of the CG series, sometimes the displayed color does not change.

-------------------------------------------------------------------------------
Specifications
-------------------------------------------------------------------------------
16-bit color depth:
Red: 5 bits (2^5=32, 0-31)
Green: 6 bits (2^6=64, 0-63)
Blue: 5 bits (2^5=32, 0-31)
The total number of colors that can display is 32*64*32=65536.

24-bit color depth:
Red: 8 bits (2^8=256, 0-255)
Green: 8 bits (2^8=256, 0-255)
Blue: 8 bits (2^8=256, 0-255)
The total number of possible combinations of colors is 256^3=16777214.

The color designation method appoints a color before a command as same as genuine Casio Basic.
(Example) Blue Locate 1,1,"Blue"

Following commands are extended.
Back-Color
RGB(
GetRGB(
HSV(
GetHSV(
HSL(
GetHSL(
Transp-Color

(Example) Back-Color Red
(Example) RGB(255,0,128) Blue Locate 1,1,"Blue"
(Example) GetRGB(12345)

(Format 1) Back-Color color
(Example) Back-Color Green
 Set a background color in green.
(Format 2) Back-Color @ color
(Example) Back-Color @Green
 Set a drawing frame out of the domain in green.

(Format) RGB(R,G,B)
 You can set any 24-bit color.
 The range of the value becomes to 0-255 with an 8 bits level each
 R: 8 bits (0-255)
 G: 8 bits (0-255)
 B: 8 bits (0-255)
 To usable at points such as Red, Green, Blue.
(Example) It is Yellow which is slightly darker than Plot/LineColor RGB(160, 160, 0) Plot/LineColor Yellow.

(Format) RGB({R,G,B})
(Example) RGB({255,255,0})
(Example) {255,255,0}->List 1
          RGB(List 1)

(Format) RGB(#16-bit color value)
Added # option of RGB(,HSV(,HSL( that set to 16-bit color directly.
(Example) RGB(#12345)
(Example) HSV(#12345)
(Example) HSL(#12345)

(Format) GetRGB(16-bit color value)
(Example) GetRGB(65535)
 Return to ListAns = {32,64,32}
  R = ListAns[1]
  G = ListAns[2]
  B = ListAns[3]

(Format) HSV(H,S,V)
(Format) HSL(H,S,L)
  H: 0-359
  S: 0-255
  V: 0-252
  L: 0-250

(* 4 colors that cannot be set by HSV() and HSL().
  #0x003F: RGB(  0,   4, 248)
  #0x041F: RGB(  0, 128, 248)
  #0xF820: RGB(248,   4,   0)
  #0xFC00: RGB(248, 128,   0)

(*Note) When the above values are used as arguments in GetHSV() and GetHSL() an error pop-up occurs.
(Format) GetHSV (16-bit color value [,N])
(Format) GetHSL (16-bit color value [,N])
[,N] Ignore errors.

===============================================================================
Transp-Color                [SHIFT]-[F4](SKETCH)-[F6]-[F6]-[F1](COLOR)-[F6]-[F5](Transp-Color)
===============================================================================
Appoint the transparent color in the bitmap drawing of the 16-bit colors.
(Format) Transp-Color
 Clear the transparent color.
(Format) Transp-Color color
(Example) Transp-Color Green
 Set the transparent color to green.
(Format2) Transp-Color #16-bit color value
(Example) Transp-Color #12345
 Set the transparent color to 12345.

===============================================================================
About VRAM
===============================================================================
Text screen and graphics screen are independently implemented in C.Basic as well as genuine Casio Basic. Only Display-VRAM is used to display to LCD by commands.

There are 3 VRAMs;
- Display-VRAM is used to output to LCD.
- Text-VRAM is an RAM area to save data for text screen.
- Graphics-VRAM is an RAM area to save data for graphics screen.

These 3 VRAMs with same size are implemented.

When a text display command runs in "text display mode", the process sends data to Display-VRAM.
When a text display command runs in "graphics display mode", the process retract Display-VRAM to Graphics-VRAM at first then transfer Text-VRAM to Display-VRAM, and then display text output in Display-VRAM.

When a text display command runs repeatedly, skipping retraction to Graphics-VRAM and transferring to Text-VRAM, then only Drawing text on -Display-VRAM is continued (still in "text display mode").

Still in this "text display mode", when a graphics command runs, retract Display-VRAM to Text-VRAM, then resume Graphics-VRAM to Display-VRAM, and then draw graphics in Display-VRAM (switch to "graphics display mode").

As you see above, memory area such as Text-VRAM and Graphics-VRAM are NOT directly used for output to LCD, but merely data storage area. So once Text mode and Graphics mode are switched, at every time of this VRAM transferring is carried out among VRAM, Text-VRAM and Graphics-VRAM.

===============================================================================
Drawing on LCD
===============================================================================
In order to draw text or graphics on screen in fx-CG series, data in VRAM is transferred to LCD.

Transferring to LCD includes quite a few overhead, so it takes totally long time (it is inefficient) to transfer data to LCD (refresh) at every single time when a draw command runs.

To get rid of the inefficiency, C.Basic provides Refresh Control function.
You can set to suppress the refresh at every single time when a draw command runs, and can set to carry out refresh in regular intervals.
This setting is available in Setup page and also by command.

With the setting for refresh in regular intervals, the last command in repeating Drawing operation may lose a chance to refresh, then before refreshing to reflect the last Drawing command the next command possibly runs.

In order to avoid this problem, we want to force the refresh then use PutDispDD to refresh screen.

===============================================================================
Extended Matrix
===============================================================================
Specification and usage of Matrix in C.Basic is different from genuine Casio Basic as follows.
C.Basic covers genuine Casio Basic's usage of matrix, real number can be used in Real Number Mode and integer can be used in Integer Mode.
Matrix in C.Basic can handle Bit (1 bit), NIBBLEB (4 bit), BYTE (1 byte), WORD (2 byte), integer (4 byte) and real number (8 byte) as type of matrix.

Add suffix to matrix name at matrix allocation to declare type of the matrix;
- [.P] or [.p]: 1-bit Integer Matrix, handling number is 0 to 1.
- [.N] or [.n]: 4-bit Integer NIBBLE Matrix, handling number is 0 to 15.
- [.B] or [.b]: 8-bit Integer BYTE Matrix, handling number is -128 to 127.
- [.W] or [.w]: 16-bit Integer WORD Matrix, handling number is -32,768 to 32,767.
- [.L] or [.l]: 32-bit Integer Long WORD Matrix, handling number is -2,147,483,648 to 2,147,483,647.
- [.F] or [.f]: 64-bit Double-Precision Real Number Matrix, handling number is 9.88131291682493e-323 to 1.7976931348623151e+308.
- [.C] or [.c] : 64*2-bit Double-Precision Real and Imaginary Number Matrix, handling number is 9.88131291682493e-323 to 1.7976931348623151e+308.

Same as genuine, the matrix is {m, n} type and is implemented as {row, column}.
As an exception, 1 bit type is an implementation of {column, row} with {X,Y} type implementation.

Since the 1 bit matrix has the same data structure as the VRAM of the screen,
When [.V] or [.v] is specified, VRAM can be read and written by assigning it to a matrix of 128 rows x 64 columns.
Furthermore, you can assign graphic VRAM with [.VG], text VRAM with [.VT] to matrix.
The index base starts at 0 and the matrix size is fixed at {216,384}.

(Example) {216,384}->Dim Mat G.V
By accessing Mat G, you can directly read and write VRAM at that point, but since it is not a display system command,
When display the screen, it must be forcibly displayed after executing the command.

(Example) {216,384}->Dim Mat G.V
Screen.G // Graphic screen selection (other graphic commands are acceptable)
1 -> Mat G[108,192]
PutDispDD // screen transfer command
You can put a dot in the middle of the graphic screen.
It is the same as PxlOn 31,63.

(Example) {216,384}->Dim Mat G.V
Screen.T // Text screen selection (Other text based commands are acceptable)
1 -> Mat G [63, 31]
PutDispDD // screen transfer command
You can put a dot in the middle of the text screen.

===============================================================================
Initialization of Matrix
===============================================================================
Same as genuine, {M, n} -> Dim Mat A Format,
[[1,2,3][4,5,6]] -> Supports Mat A Format initialization.

In addition at fx-5800P,
100->Dim A
It supports Format.
0->Dim A
Deletes matrix A.

In Mat matrix initialization command [[]], it is possible to insert newline and space.
(Example)
[[0B11001100,
0B00110011,
0B11001100,
0B00110011
]]->Mat A.B

Added Dim Dim option.
(Usage) {m,n}->Dim Dim Mat A(real address of the Mat)
(Example) {128,1}->Dim Mat A.B
(Example) {64,1}->Dim Dim Mat B.W(VarPtr(Mat A))
Mat A and Mat B access in the same domain, but are different in byte access or the word access.

===============================================================================
Access to matrix
===============================================================================
In addition to the Mat A[1,1] Format,
Mat was omitted
A[1,1]
With only the first row of access
A[1]
Notation is also possible.

Furthermore, only when the subscript is the numerical value 0 to 9,
A0
A5
You can write it.

The variable of this notation is automatically reserved for the matrix if the matrix which becomes the entity is not reserved in advance.
(Example) A1+123->B5
If Mat A and Mat B are not secured, at the time the variable is 1st accessed
9->Dim A
9->Dim B
The same initialization as in 1 is executed automatically, and A1 to A9 and B1 to B9 can be used.

(Example) '#Mat 0
A1+123->B5
In the case that Mat A and Mat B are not secured,
10->Dim A
10->Dim B
The same initialization as in A0 to A9 and B0 to B9 can be used automatically.

(Example) '#Mat 0
2->Dim B
A1+123->B5
In the case of,
10->Dim A
Since only Mat A is initialized and Mat B is not reacquired, an error will occur at the time of accessing B5.
In this case you can use A0 ~ A9 and B0 ~ B1.

===============================================================================
Matrix Type Conversion
===============================================================================
The matrix type (1 bit, byte, word, long word, real number) can be arbitrarily changed even after matrix reservation.
(Example) [[1,2,3,4] [5,6,7,8]] -> Mat A.B
Mat A->Dim Mat A.W
You can change the Mat A matrix of byte type to word type.
The number of elements will change according to the type size after change.
[[0x12,0x34][0x56,0x78]]->Mat A.W
The result is the same.

(Note) Changes from a 1bit/4bit matrix and changes to 1bit/4bit type matrix are reversed in rows and columns.
This is because the 1bit/4bit type matrix is implemented in X and Y type, so it is a transposed matrix relation with ordinary m, n type matrix.
{127,63}->Dim Mat A.P
It secures it as a buffer that can be used as the virtual memory of the full screen bitmap data of the LCD screen.
Mat A->Dim Mat A.B
By changing to a byte type matrix,
The element size is {63,16}.

===============================================================================
1st Index of Matrix
===============================================================================
In genuine Casio Basic, the index of a matrix starts with 1, but in C.Basic it can start with 0.
You can select the beginning of a matrix by describing it in setup or comment field.
(Example) #Mat 1
It starts from 1 as before.
(Example) #Mat 0
{3,2}->Dim Mat A
 The matrix to be allocated is A[0,0] to A[2, 1].

At the same time, screen coordinates are also valid up to 0. This makes the whole screen the Drawing target area
(Example) Pxlon 0,0

===============================================================================
Matrix Review
===============================================================================
You can display binary and hexadecimal numbers in Mat matrix editor.
Pressing [F5] in matrix editing mode will display binary numbers, [F6] will display hexadecimal numbers.
To return to the decimal number display, press [F5] [F6] again.
However, the binary notation is up to the matrix of byte (1 byte) and word type (2 bytes).

Press the [OPTN] key to change to the list name display.
Press the [VARS] key to change to the character string display.

===============================================================================
Supported list function
===============================================================================
List functions are implemented by assigning one dimension of Mat.
List 1~26 is independent List.
Mat a ~ z of lower case Mat matrix to List 27 ~ 52.
List 27[5] = Mat a[5, 1]
List 28[5] = Mat b[5, 1]
List 29[5] = Mat c[5, 1]
List 100[5] = Mat 100[5, 1]
List 1000[5] = Mat 1000[5, 1]
It has the same meaning.

The following command of genuine function is supported.

List Ans
10->Dim List 1
{1,2,3,4,5}->List 1
Seq(X^2,X,1,10,2)->List 2
Augment(List 1,List 2)->List 3
Mat>List(Mat A,2)->List 1
List>Mat(List 1, List 2, ...)->List 9
Fill(3, List 1)
Min(List 1)
Max(List 1)
Mean(List 1)
Sort A(List 1)
Sort B(List 1)
Sum List 1
Prod List 1

Arithmetic and functional arithmetic including List.

===============================================================================
Supported vector function
===============================================================================
 Vct
 DotP(
 CrossP(
 Angle(
 UnitV(
 Norm(
 ClrVct
(*)The area of Vct A~Z becomes independent.
To change [VARS] key for Vct display of Mat/List/Vct screen.

===============================================================================
Strings in C.Basic
===============================================================================
Like the original Casio Basic, you can use Str character variables and string functions, but the substance of the string is implemented as a matrix.

By attaching $ as the prefix, the Mat matrix is recognized as a string.
(Example) ["ABCDEF"] -> Mat A
Locate 3,3,$Mat A
"ABCDEF" is displayed on the screen coordinates (3, 3).

At first,
{7,1}->Dim Mat A.B
The same initialization as that is done automatically.
The string is stored as byte type data in the matrix.

-Character string functions compatible with Casio Basic
 + (Concatenation of character strings)
 StrJoin(
 StrLen
 StrCmp(
 StrSrc(
 StrLeft(
 StrRight(
 StrMid(
 Exp>Str(
 Exp(
 StrUpr(
 StrDwr(
 StrInv(
 StrShift(
 StrRotate(

(Example) "ABCDEF"->Str 1
Locate 3,3.StrRight(Str 1,3)
"DEF" is displayed on the screen coordinates (3, 3).

The characters used in CG series include single - byte characters (alphanumeric characters, some commands) and double - byte characters (almost all commands, special characters and kana)
Internally, 1 byte and 2 byte characters are mixed, but handling with character functions is handled as one character as well as genuine.
Please pay attention to the position of the character when accessing the matrix element where the character string is stored directly.

===============================================================================
Initialization of String
===============================================================================
The same character variable Str 1-20 as genuine implicitly uses <r> of Mat matrix by default.
By default, the number of characters is limited to 255 characters.
The Str character variable is automatically secured as a Mat matrix and can be used with genuine compatibility in the next character string command, so it is not necessary to be conscious of the matrix.
When one or more Str strings are used in a program, if Maximum number of Str <number> is M, <r> matrix with M rows is automatically created as follows;
　{M,256}→Dim Mat <ｒ>
(note) <r> means bold r. Keypress of the bold r is [ALPHA]+[x^2].

The Mat matrix which is the substance of the Str character variable can be arbitrarily specified, and it is specified in the comment field before using the Str variable.
(Example) '#Str A
We secure the Str variable as Mat A.
{20,65}->Dim Mat A.B
It is the same as.
(Example) '#Str B,30,256
Secure the Str variable as Mat B as a possible variable up to 30 and 255 characters.

The following Format can be used for assigning a character string.
(Example) "ABCDEEF"->Str 1
(Example) ["ABC","TEST","1+3+5"]->Mat A
We automatically allocate Mat A [3,6] matrices of byte type and place character strings on each element.
 Mat A[1,1] = "ABC"
 Mat A[2,1] = "TEST"
 Mat A[3,1] = "1+3+5"
.
To access "ABC" with a character string correspondence command, it is $Mat A, or $Mat A[1], or $Mat A[1,1].
To access "1+3+5" it will be $Mat A[3], or $Mat A[3,1].
(Example) Locate 1,1,$Mat A
Locate 1, 1, same as "ABC".
(Example) Locate 1,1,$Mat A[3,3]
It is the same as Locate 1,1,"3+5".

This command corresponds to a character string in the current version. It is used in $ Mat Format instead of "".
- ""
(Example) $Mat A[1]
It is the same as "ABC".
-?
(Example)?->$Mat A
Enter a string in matrix Mat A. The number of characters is limited by the number of secured elements.
Locate
- Text
- LocateYX
- Eval(
(Example) Eval("1+2+3")->6
(Example) Eval($Mat A[3,3])->8
Evaluates the string as a mathematical expression and returns the value.

===============================================================================
Sprintf - an Extended Command
===============================================================================
As genuine there is no conversion function from number to character string, Sprintf (C language compatible specification of SDK was added as additional character string function.
(Specification) Sprintf ("Format specifier", argument 1 [, argument 2 [, argument 3]]))
(Example) Sprintf ("A=%4dB=%3.2f",%A,#B) -> Str 1
When A=1234 and B=45.678,
The character string assigned to Str 1 is
A=1234 B=45.68
Since Format specification is compatible with sprintf in C language, the numerical expression such as exponential notation etc. is somewhat different.
  Up to three arguments can be specified, and integer / real number / character string can be specified.
The% prefix specifies an integer, and the prefix specifies a real number.
  If prefix is left out, it becomes the execution mode (real / integer) at that point.
  There is no error check for Format specification and argument correspondence, so please be careful because there is a possibility of reset or restart if an error occurs with Sprintf (command).

(Attention) The subtraction character "-" is necessary to input from [F4](CHAR).

===============================================================================
Command Reference
===============================================================================
-------------------------------------------------------------------------------
Compatible Commands with Casio Basic
-------------------------------------------------------------------------------
?
(Disps)
->
If ~ Then ~ Else ~ IfEnd
Lbl ~ Goto
>= <= < > = <>

Dsz / Isz
=>
Locate
Menu

For ~ To ~ Step ~ Next
While ~ WhileEnd
Do ~ LpWhile
Break
Return
Stop
Getkey
Prog

ClrMat
ClrList
Mat (Matrix Calculations is supported.)
List (Arithmetic Calculations Using Lists is supported.)
Dim
Fill(
Seq(
Augment(
Mat> List(
List> Mat(
Min(
Max(
Mean(
Sort A(
Sort B(
Sum
Prod
Swap / *Row / *Row+ / Row+
Trn
Identity
DotP(
CrossP(
Angle(
UnitV(
Norm(  (*Mat is not supported)
nPr
nCr

i / Arg / Conjg / ReP / ImP / >r/_theta / a+bi
Real / a+bi / r/_theta

Cls ClrText ClrGraph
ViewWindow
Plot / PlotOn / PlotOff / PlotChg
Circle
Line / F-Line
Vertical / Horizontal

PxlOn / PxlOff / PxlChg
PxlTest(
Text

SketchNormal / SketchThick / SketchBroken / SketchDot / SketchThin
S-L-Normal   / S-L-Thick   / S-L-Broken   / S-L-Dot / S-L-Thin

G-Connect / G-Plot
CoordOn / CoordOff
GridOn / GridOff / GridLine
AxesOn / AxesOff / AxesScale
LabelOn / LabelOff
DerivOn / DerivOff
BG-None / BG-Pict
FuncOn / FuncOff
S-WindAuto / S-WindMan

DrawGraph (partially supported)
Graph Y= (partially supported)
GraphY (partially supported)

Graph(X, Y) = (Partially supported)
DrawStat (partially supported)
S-Gph1, S-Gph2, S-Gph3, DrawOn, DrawOff, Scatter, xyLine, Square, Cross, Dot

Xmin Ymin Xmax Ymax Xscl Yscl Xfct Yfct Xdot
T [theta] Min T [theta] Max T [theta] Ptch

Deg Rad Grad

And Or Not Xor

Abs Int frac Intg
!
MOD
Rmdr Int/
Log ln logab(
10 ^ x e ^ x
X ^ -1
Sqr x ^ 2
Sqr ^ -3
Sin cos tan
Sin^-1 cos^-1 tan^-1
Sinh cosh tanh
Sinh^-1 cosh^-1 tanh^-1

Femto pico nano micro milli Kiro Mega Giga Tera Peta Exa

(deg) r (rad) g (gra)
> DMS

Str
StrJoin(
StrLen
StrCmp(
StrSrc(
StrLeft(
StrRight(
StrMid(
Str>Exp(
Exp(
StrUpr(
StrDwr(
StrInv(
StrShift(
StrRotate(

StoPict / RclPict
RclCapt

Ran#  RanInt#(  RanNorm#(  RanBin#(  RanList#(
Rnd  RndFix(
Norm / Fix / Sci
Eng / EngOn / EngOff

Black Blue Red Magenta Green Yellow Cyan
Plot/Line-Color

===============================================================================
Command reference extended command
===============================================================================
-------------------------------------------------------------------------------
?                        [SHIFT]+[VARS](PRGM)-[F4](?)
-------------------------------------------------------------------------------
You can use more options in input command.
(Usage) ?([x][,y][,width][,"SpaceChar"][,limit][,R][,M])
(Example) "A="?()->A
Display "A=" then wait for inputting A value.
(Example) "A="?(,,,,,R)->A
Display "A=" then wait for inputting A value in reversed display.
(Example) "A="?(,,8,,,R)->A
Display "A=" then wait for inputting A value within only 8 digits in reversed display.
(Example) "A="?(3,4,5,">",5)A
Display "A=" then wait for inputting A value at(X=3,Y=4) within 5 digits or 5 characters and the blank is made up in ">". (Example) ?(3,4,5,,5,R)A
Display "A=" then wait for inputting A value at(X=3,Y=4) within 5 digits and 5 characters in reversed display.

[@] The drawing of the command becomes current VRAM.
(Example) "A="?(@30,40,5,">",5)A
Display "A=" on current VRAM then wait for inputting A value at(px=30,py=40) only 5 digits and 5 character the blank is made up in ">".
(Example) "A="?(@30,40,5,">",5,,M)A
 Display mini font "A=" on current VRAM then wait for inputting A value at(px=30,py=40) only 5 digits and 5 character the blank is made up in ">".

-------------------------------------------------------------------------------
Menu                        [SHIFT]+[VARS](PRGM)-[F3](JUMP)-[F6](Menu)
-------------------------------------------------------------------------------
The color of title is valid just before the Menu command.
The color of menu item is valid Plot/Line-Color.
The color of menu background is valid Back-Color.
(Example)
Plot/Line-Color Blue
Back-Color Black
Red Menu "MENU TITLE","1st item",1,"2nd item",2

When attach "@" after a command, it is compatible with the FX version.

-------------------------------------------------------------------------------
Fix                        [SHIFT]+[MENU](SET UP)-[F6]-[F1](DISPLAY)-[F1](Fix)
Sci                        [SHIFT]+[MENU](SET UP)-[F6]-[F1](DISPLAY)-[F2](Sci)
Norm                        [SHIFT]+[MENU](SET UP)-[F6]-[F1](DISPLAY)-[F3](Norm)
Eng                        [SHIFT]+[MENU](SET UP)-[F6]-[F1](DISPLAY)-[F4](ENG)-[F3](Eng)
-------------------------------------------------------------------------------
Fix, Sci, Norm can take integer parameter in range of 0 to 15.
Fix: Setting is almost same as genuine Casio Basic, except x is in exponent notation when |x| ≧ 10^17.

Sci：Setting is almost same as genuine Casio Basic, except Sci 0 sets 16 significant figures.

Norm：Norm 1 and Norm 2 set 10 significant figures same as genuine Casio Basic. Norm 0 sets 16 significant figures.
Norm n sets n significant figures. Condition of exponent notation depends on following range of x;
- Norm 1 …… 0.01 ＞ |x|, |x| ≧ 10^10
- Norm 2 …… 0.000000001 ＞ |x|, |x| ≧ 10^10
- Norm n (3≦n≦15) …… 0.01 > |x|, |x| ≧ 10^n
- Norm 0 …… 0.01 > |x|, |x| ≧ 10^15


Eng, Norm, Fix, Sci return current state (On or Off).

Eng returns the current state of 3-digit seperator:
- Return value 0: state of EngOff
- Return value 1: state of EngOn
Norm, Fix, Sci
To return current status, set negative value as parameter*;
(Note*) To add the parameter, ( ) is not necessarily required.
If current state is Norm1, return values are:
- Norm (-1) gives 1
- Fix (-1) gives -1
- Sci (-1) gives -1

If current state is Fix 8, return values are:
- Norm (-1) gives -1
- Fix (-1) gives 8
- Sci (-1) gives -1

-------------------------------------------------------------------------------
EngOn                        [SHIFT]+[MENU](SET UP)-[F6]-[F1](DISPLAY)-[F4](ENG)-[F1](EngOn)
-------------------------------------------------------------------------------
Enable 3-digit separator.
(Example) EngOn 3
 After this commend, number is displayed with 3-digit separator ",".
 EngOff to disable 3-digit seperator.

-------------------------------------------------------------------------------
RndFix(                        [OPTN]-[F6]-[F4](NUMERIC)-[F6]-[F1](RndFix)
-------------------------------------------------------------------------------
Added option of RndFix(for calculating the maximum number of significant digits.
(Format) RndFix(value,Sci digits)
(Example) RndFix(1.23456789e-123,Sci 5)
Return value of 1.2346e-123

-------------------------------------------------------------------------------
StoPict                        [OPTN]-[F6]-[F6]-[F2](PICTURE)-[F1](Store)
RclPict                        [OPTN]-[F6]-[F6]-[F2](PICTURE)-[F2](Recall)
-------------------------------------------------------------------------------
These commands can be used in 2 different modes, a mode storing in storage memory and a mode storing in heap memory secured in main memory.
To set the mode, open "Setup" page by [SHIFT][MENU](Setup), select to item "Pict", then set [F1](MEM) or [F2](Heap).
When "Heap" is set, we lose compatibility of Pict file with genuine Casio Basic, but access speed to Pict file will be faster.
The program source itself keep compatibility, so source in genuine Casio Basic can run in C.Basic.

-------------------------------------------------------------------------------
ElseIf                        [SHIFT]+[VARS](PRGM)-[F1](COMMAND)-[F5](ElseIf)
-------------------------------------------------------------------------------
(Format) If ~ Then ~ ElseIf ~ IfEnd
(Example)
(Casio Basic)
If A
 Then Locate 1,1,"A"
 Else If B
  Then Locate 1,2,"B"
  Else If C
   Then Locate 1,3,"C"
  IfEnd
 IfEnd
IfEnd

(C.Basic)
If A
 Then Locate 1,1,"A"
 ElseIf B
 Then Locate 1,2,"B"
 ElseIf C
 Then Locate 1,3,"C"
IfEnd

As you see above, ElseIf is similar to Else If, but it makes the command need one nest only. Use only one IfEnd in the end.

The number of IfEnd corresponding to If is not strictly checked in genuine Casio Basic. But in C.Basic you can set if you want the strict check or not at item "IfEnd Check" in "Setup" page.
Set "On" at "IfEnd Check", an error message may pop up in run time, and cursor locates at If command which does not have any corresponding IfEnd.

-------------------------------------------------------------------------------
Locate                        [SHIFT]+[VARS](PRGM)-[F6]-[F4](I/O)-[F1](Locate)
-------------------------------------------------------------------------------
(Format) Locate [@][!]y,x,[##],<"string" or expression>[,N/O/R/V][,F][,height]
 [@] The drawing of the command becomes current VRAM.
 [!] Even if the extended font is introduced, drawing in the original font forcibly.
 [##] enable GB font display
 [%%] disable GB font display
 [,N] Normal
 [,R] Reverse
 [,O] Or
 [,V] reVerse or
 [,F] Fixed 18 pixel pitch.
 [,height] specifies the height of the font to draw.

 (Example) Locate 1,2,"Test",R
  Reversed "Test" is displayed at location (1,2).

-With prefix # to expression (parameter) in Locate as well as Sprintf, Text and Disp commands makes evaluation of the expression in real number.
 In "Integer Mode", the expression with prefix # allows displaying string of "real number" which reflects the evaluation in real number. Prefix # helps display in "Integer Mode" to handle "real number" by Locate, Sprintf, Text and Disp commands.
(Example)
 '#CBINT
 10->A
 Locate 1,2,log 123+A
 In Integer Mode, "log 123+A" is rounded to 12, but
(Example)
 '#CBINT
 10->A
  Locate 1,2,#log 123+A
    With the prefix #, it is not rounded and display 12.089905111.
An expression after prefix # is handled as real number, but variable (for Example A above) is still used as integer variable, so prefix % should not be added.

-------------------------------------------------------------------------------
Switch                        [SHIFT]+[VARS](PRGM)-[F1](COMMAND)-[F6]-[F6]-[F6]-[F1](Switch)
Case                        [SHIFT]+[VARS](PRGM)-[F1](COMMAND)-[F6]-[F6]-[F6]-[F2](Case)
Default                        [SHIFT]+[VARS](PRGM)-[F1](COMMAND)-[F6]-[F6]-[F6]-[F3](Default)
Break                        [SHIFT]+[VARS](PRGM)-[F1](COMMAND)-[F6]-[F6]-[F6]-[F4](Break)
SwitchEnd                [SHIFT]+[VARS](PRGM)-[F1](COMMAND)-[F6]-[F6]-[F6]-[F5](SwitchEnd)
-------------------------------------------------------------------------------
C.Basic supports Switch statement from C programming language.
(Format)
Switch <value or expression>
 Case <value or expression>
  [<Expressions>]
  [Break]
 Default
  [<Expressions>]
  [Break]
SwitchEnd

You can set multiple cases as you want.
Without "Break", program control goes through to the next "Case".
Note, "Default" should be placed in the last, otherwise unexpected result may occur.

(Example)
Switch A
 Case 1
  Locate 1,1,"A"
  Break
 Case 2
  Locate 1,2,"B"
 Case 3
  Locate 1,3,"C"
  Break
 Default
  Break
SwitchEnd

-------------------------------------------------------------------------------
ACBreak                        [SHIFT]+[VARS](PRGM)-[F2](CONTROL)-[F6]-[F2](ACBreak)
-------------------------------------------------------------------------------
"ACBreak" command gives exactly the same result as to press [AC] key during program runs.

Availability of "ACBreak", enable or disable can be set at item "ACBreak" in "Setup" page. When "ACBreak" is Off (disable), the command "ACBreak" is ignored and is not breaking the program.

(Example) ACBreak

Input command "ACBreak" and "Stop" right after ACBreak, then "ACBreakStop" command cancel all the ACBreak after this command. This gives exacltly the same result as to set "Off" for ACBreak in "Setup" page.

(Example) ACBreakStop

-------------------------------------------------------------------------------
Local                        [SHIFT]+[VARS](PRGM)-[F2](CONTROL)-[F5](Local)
-------------------------------------------------------------------------------
In C.Basic all the variables including small letter variables are "global variable" as default. But some small letter variables can be used as "local variable" with "Local" command.

Set small letter variables to "Local" command in a program, then those variables can be local, the scope is only within the single program.

(Example) Local x,y,x
 - Parameters x, y and z are now local variables.
 - Maximum 10 small letters can be set as local variable.
 - In the same order of the parameters can be passed to sub-routine with Prog command.

(Example)
In sub-routine "TEST", use Local with 3 small letters for local variables:

Local x,y,x
(Describe this in the sub-routine, the position can be where ever you like...)

Then in main routine describe use Prog command with 3 extra parameters;

Prog "TEST",123,456,N
(At calling sub-routine "TEST", pass 123, 456 and N to "TEST" in the same order, that means 123->x, 456->y, N->z in the sub-routine, other variables are still global.)

Using local variables, a recurrence algorithm is available in C.Basic, but at this moment maximum nesting is about 128 levels.

-------------------------------------------------------------------------------
Prog                        [SHIFT]+[VARS](PRGM)-[F2](CONTROL)-[F1](Prog)
-------------------------------------------------------------------------------
Use with "Local" command, "Prog" can handle arguments and returns with sub program.

(Example)
"MAIN" Program
10->X
20->Y
X+1->a
Y*2->b
Prog "SUB",X,Y
Disp Ans
Disp a
Disp b

"SUB" Program
Local a,b
Dips a
Disp b
Return a+b

Result Output
10
20
30
11
40

"MAIN" program calls "SUB" program calculating sum of 2 numbers and display the result.
In the sub program, variables a and b is secured as local variables, so cannot access to global variables a and b.
In the main program, a and b are global variables, so the variables are free of the influence of global variables a and b in the sub program.

-------------------------------------------------------------------------------
Return                        [SHIFT]+[VARS](PRGM)-[F2](CONTROL)-[F2](Return)
-------------------------------------------------------------------------------
"Return" command returns from sub-routine, in C.Basic a return value can be sent back to main routine.

(Example) Return
  The return value, a value of is substituted in "Ans".

-------------------------------------------------------------------------------
Gosub                        [SHIFT]+[VARS](PRGM)-[F2](CONTROL)-[F6]-[F1](Gosub)
-------------------------------------------------------------------------------
"Gosub" command allows to use sub-routine within single program.

(Example) Gosub A
Jump to "Lbl A", proceed codes until "Return", then resume back.

(Example) Gosub A,123,456
With Local command, arguments can be used as similar to Prog command, but all the codes are in single program, so the variables are global.

(Example)
10->X
20->Y
X+1->a
Y*2->b
Gosub A,X,Y
Disp Ans
Disp a
Disp b
  Stop

Lbl A
local a,b
Dips a
Disp b
Return a+b

Result Output
 10
 20
 30
 10
 20

This sample program is similar to (Example) program of Prog command. Variables a and b are secured as local variable, so cannot access to global variables a and b in this program.

-------------------------------------------------------------------------------
ElemSize(                [OPTN]-[F2]-(MAT)-[F6]-[F5](SIZE)-[F2](Elem)
RowSize(                [OPTN]-[F2]-(MAT)-[F6]-[F5](SIZE)-[F3](Row)
ColSize(                [OPTN]-[F2]-(MAT)-[F6]-[F5](SIZE)-[F4](Col)
-------------------------------------------------------------------------------
Functions to obtain size of a matrix.

ElemSize(
Return size (in bit) of element.
(Example) ElemSize(Mat A)
RowSize(
Return m of {m,n}, row size of a matrix.
ColSize(
Return m of {m,n}, column size of a matrix.

-------------------------------------------------------------------------------
MatBase(                [OPTN]-[F2]-(MAT)-[F6]-[F5](SIZE)-[F1](Base)
-------------------------------------------------------------------------------
Functions to obtain start index value of matrix
(Example) MatBase(Mat A)

-------------------------------------------------------------------------------
Getkey                        [SHIFT]+[VARS](PRGM)-[F6]-[F4](I/O)-[F2](Getkey)
-------------------------------------------------------------------------------
There are following features for Getkey in addition to genuine Casio Basic;
  - Getkey: compatible with genuine Casio Basic.
  - Getkey1: pause until any key is pressed (same as SDK's Getkey).
  - Getkey2: clear key buffer then accept input. (Recommended use in SH3 models.)
  - Getkey3: pause for a certain period before accept input.
  - GetkeyM: puts multiple pressed keys into a list.
* The number right after Getkey should be input by number keys.

Keycode is fully compatible with genuine Casio Basic, but not compatible with SDK.

Power Off by [SHIFT]+[AC] as well as [AC] is not supported yet to obtain keycode.

(Example) Getkey3(128)
Set 128 Ticks count (1 sec) for pause. This does not return keycode during the pause, but returns keycode of last key press after the key wait period.

(Example) Getkey3(128,A)
Pause until 128 Ticks count of current timer with initial timer as set by A (in Ticks count).

* In case Getkey1 does not properly work in SH3 version, use Getkey2 instrad of Getkey1.

 (Example) GetkeyM->List 1
Press EXE and F1 will result in {79,31}

* When validate Exec TimeDsp, the time measurement stops during Getkey1/2, but can make reset & restart by setting.
 You can set it by setup or the following control commands.
(Format) '#GetkeyC
 It is the stop of the timer of the default, a continuation mode.
(Format) '#GetkeyR
 Timer resets after Getkey1/2.

-------------------------------------------------------------------------------
Try~Except~TryEnd                [SHIFT]+[VARS](PRGM)-[F2](CONTROL)-[F6]-[F3](Try)
-------------------------------------------------------------------------------
Exception handling can be performed according to the error.
(Format)
Try <expression>
 Except [<error code>]
  <Expressions>
TryEnd

You can have more than one Except for different error codes.
If there is no error in <program>, processing will move after TryEnd.
If error occurs and the corresponding error code matches the value after Except, processing will move to <expressions> and executes, then goes after TryEnd.
When error that does not match the error code occurs, an error pop-up appears because there is no corresponding Except <error code>.
Except with no argument corresponds to all errors. If any error occurs, processing will move to <expressions> and executes.
When there are more than one conditions that matches the error, processing will move to the Except that has the least line number compared to another one.

(Example)
Try 3*4+
 Except 1
  "Syntax Error"
TryEnd

"Syntax Error" is executed instead of showing error message, since "Syntax Error" error code is 1.

(Example)
Try 3*4/0
 Except 1
  "Syntax Error"
 Except 40
  "Divide by zero"
TryEnd

"Divide by zero" is executed instead of showing error message, since "Division By Zero" error code is 40.

(Example)
1 Try 0/0
2  Except
3   "Error"
4  Except 40
5   "Divide by zero"
6 TryEnd

Since "Except " has the least line number compared to "Except 40" (i.e. no.2 > no.4), processing will instead move to "Except " and run "Error", then it will skip "Except 40" and move to TryEnd.

The sample program is in CBasic_sample/Try_Except.
Refer to ErrorCode_List.txt for the error code in the ZIP package.

-------------------------------------------------------------------------------
Version                        [SHIFT]+[MENU](SET UP)-[F6]-[F6]-[F6]-[F6]-[F5](Version)
(0.45-)
-------------------------------------------------------------------------------
Return version number.
(Example) Version
 When ver.0.45, return value is 45.

-------------------------------------------------------------------------------
System(                        [SHIFT]+[MENU](SET UP)-[F6]-[F6]-[F6]-[F6]-[F4](System)
(0.49-)
-------------------------------------------------------------------------------
Return to some system value.

System(0):return to version of C.Basic (same as Version)
System(1):return to address of VRAM. (162KB)
System(2):return to address of text VRAM. (162KB)
System(3):return to address of graphic VRAM. (162KB)
System(4):return to address of work buffer. (256KB)
System(10):return to address of clip buffer. (32KB)
System(-4):return to remainder of the heap size. (KB)
System(-3):return to the heap area size. (KB)
System(-2):return to OS version. (Example 311)
System(-1):return to model name. (50 in CG50)

===============================================================================
Extended Graphics Commands
===============================================================================
The true coordinate of the screen of the CG10/20/50 series is (0,0) -(383,215), but uses it with a coordinate level of (0,-24)-(383,191) in C.Basic.

===============================================================================
When [:] is added just after a command, current VRAM is targeted for drawing regardless of text mode and a graphic mode.
-------------------------------------------------------------------------------
(Example) Locate 2,2,"String":
            Text 16,1,"TextString":

The end after the command [:], no screen update.
Please use transfer commands such as PutDispDD to let you display LCD by a Drawing result.

-------------------------------------------------------------------------------
When add [@] just after a command, current VRAM is targeted for Drawing.

(Example)
Text 1,1,"Graphic"
Locate @1,2,"Text"

(Example)
Locate 1,1,"Text"
Text @24,10,"Graphic"

-------------------------------------------------------------------------------
Those below commands support clear and reverse function by adding new parameters C or X at the end;

Line
F-Line
Circle
Rect(
FillRect(
Add [,C] to clear and [,X] to reverse the drawn patterns.
(Example) F-Line 1,1,30,20,X

-------------------------------------------------------------------------------
Text                        [SHIFT]-[F4](SKTCH)-[F6]-[F6]-[F2](Text)
-------------------------------------------------------------------------------
(Format) Text [@][!]y,x,[##]<"string" or expression>,[,N/O/R/V][,F/FM/FMB/M/MB/FX/X][,height]
[@] The Drawing of the command becomes current VRAM.
[!] Even if the extended font is introduced, drawing in the original font forcibly.
[##] enable GB font display
[%%] disable GB font display
[.N] Normal
[.R] Reverse
[,O] Or
[,V] reVerse or
[,F] Fixed pitch (12dots space fixation)

(Example) Text 20,80,"Test",R
"Test" is displayed by reversing display by graphic coordinate (80,20).

(Example) Text 20,80,"Test",,F
"Test" is displayed a mini-font with fixed pitch (12dots space fixation).

(Example) Text 20,80,"Test",,M
"Test" is displayed a minimini-font.

(Example) Text 20,80,"Test",,MB
"Test" is displayed a minimini-bold-font.

(Example) Text 20,80,"Test",,FM
"Test" is displayed a fixed pitch  minimini-font.

(Example) Text 20,80,"Test",,FMB
"Test" is displayed a fixed pitch minimini-bold-font.

(Example) Text 20,80,"Test",,X
(Example) Text 20,80,"Test",,FX
"Test" is displayed a mini-fx style 6x8 font.

(Example) Text 20,80,"Test",,,16
Display 16 dots by the upper end.
2 lower dots are not displayed.

-------------------------------------------------------------------------------
LocateYX                [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F3](LocateYX)
-------------------------------------------------------------------------------
To use the Locate command like Text command.
(Format) LocateYX [@][!]y,x,[##]<"string" or expression>,[,N/O/R/V][,F][,height]
[@] The Drawing of the command becomes current VRAM.
[!] Even if the extended font is introduced, drawing in the original font forcibly.
[##] enable GB font display
[.N] Normal
[.R] Reverse
[,O] Or
[,V] reVerse or
[,F] Fixed 18 pixel pitch.

Letter indication of the size same as Locate is possible to a graphic screen.
Y coordinate becomes the coordinate definition as well as Text command earlier.
It becomes the reversing display in [,R] in the last of the command.
(Example) LocateYX 20,80,"Test",R
"Test" is displayed by reversing display by graphic coordinate (80,20).

-------------------------------------------------------------------------------
Rect                        [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F6]-[F1](Rect)
-------------------------------------------------------------------------------
Display a rectangle. The coordinate becomes the true coordinate definition.
(Example) Rect 1,1,127,63

-------------------------------------------------------------------------------
FillRect                [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F6]-[F2](FillRect)
-------------------------------------------------------------------------------
Display the filled rectangle.
(Example) FillRect 1,1,127,63

-------------------------------------------------------------------------------
ReadGraph(                [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F6]-[F3](ReadGraph)
-------------------------------------------------------------------------------
Read the bitmap data of the graphic screen by a bit unit.
(Format) ReadGraph(px1,py1,px2,py2) -> Mat A
 (px1,py1)-(px2,py2) to  Mat A .
 It is not necessary to secure the Mat array beforehand. at appropriate array size automatically.
 When there is not the type definition of the Mat array, it becomes the 16 bit type.

-------------------------------------------------------------------------------
WriteGraph                [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F6]-[F4](WriteGraph)
-------------------------------------------------------------------------------
Display bitmap data.
(Format 1) WriteGraph x,y,dx,dy,Mat A ,P1[,P2]
Draw data of Mat A in width dx, the range of height dy from coordinate (x,y) of the graphic screen.
 P1 parameter
  [,N] normal
  [,R] reverse
  [,M] mesh
 P2 parameter
  [omit] over
  [,X] xor
  [,O] or
  [,A] and

(Example) [[1,2,4,8,16,32,64,128]] -> Mat A
WriteGraph 80,20, 8,8, Mat A, N

(Format 2) WriteGraph x,y,dx,dy,Mat A[m,n] ,P1[,P2]
Draw data from [m,n] of Mat A in width dx, the range of height dy from coordinate (x,y) of the graphic screen.
(Example) [[16,32,64,128][128,64,32,16]] -> Mat A
WriteGraph 80,20, 4,4, Mat A[1,1], N
WriteGraph 80,24, 4,4, Mat A[2,1], N
A figure of [<] is drawn from coordinate (80,20) of the graphic screen.

WriteGraph 80,20,4,8,Mat A,N
But it becomes the same result.

The bitmap data are 8 bits width, and leaning to the left becomes the standard.
(g1m mode above)

(g3m mode)
*Only in the case of a 1 bit Mat/List, it becomes the monochromatic Drawing.
It becomes the 16 bits color drawing other than it.

If you need transparent color, use Transp-Color command.

-------------------------------------------------------------------------------
DotGet(                        [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F6]-[F6]-[F1](DotGet)
-------------------------------------------------------------------------------
(Example) DotGet( px1,py1, px2,py2)->Mat A[x,y]

-------------------------------------------------------------------------------
DotPut(                        [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F6]-[F6]-[F2](DotPut)
-------------------------------------------------------------------------------
 (Example)DotPut( Mat A, x,y, px1,py1, px2,py2)
 (Example)DotPut( Mat A[x,y], px1,py1, px2,py2)->Mat B
 (Example)DotPut( Mat A[x,y], px1,py1, px2,py2)

-------------------------------------------------------------------------------
DotTrim(                [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F6]-[F6]-[F3](DotTrim)
-------------------------------------------------------------------------------
 (Example)DotTrim(Mat A, x1,y1,x2,y2)->Mat B
 (Example)DotTrim(px1,py1,px2,py2)->Mat A

-------------------------------------------------------------------------------
CellSum(                [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F6]-[F6]-[F5](CellSum)
-------------------------------------------------------------------------------
 (Example)CellSum(Mat B[X,Y])->C

-------------------------------------------------------------------------------
DotLife(                [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F6]-[F6]-[F4](DotLife)
-------------------------------------------------------------------------------
 (Example)DotLife( Mat A, x1,y1,x2,y2)->Mat B

===============================================================================
Other Extended Commands
===============================================================================
-------------------------------------------------------------------------------
KeyRow(                        [SHIFT]+[VARS](PRGM)-[F6]-[F4](I/O)-[F5](KeyRow)
-------------------------------------------------------------------------------
Return the key matrix.

       Returning bits (in binary)
         bit6 bit5 bit4 bit3 bit2 bit1
   Row--------------------------------------Row
    09    F1    F2   F3   F4   F5   F6       09
    08    SHIFT OPTN VARS MENU <-  (up)      08
    07    ALPHA ^2   ^    EXIT (dw) ->       07
    06    XTT   log  ln   sin  cos  tan      06
    05    ab/c  F<>D  (    )    ,   ->       05
    04    7     8    9    DEL                04
    03    4     5    6    x    div           03
    02    1     2    3    +    -             02
    01    0     .    EXP  (-)  EXE           01
   Row--------------------------------------Row

(Example)  KeyRow(9)
When press [F4] and [F6] keys at the same time, bit3 and bit1 come to 1, then return value is 2^3 + 2^1 = 10.

-------------------------------------------------------------------------------
Ticks                        [VARS]-[F3](Extend)-[F1](Ticks)
-------------------------------------------------------------------------------
128 ticks/s timer.
(Example) 0 -> Ticks
Initialize the internal timer.

At the 32 bits counter which the internal timer counts it at 128 ticks/s, and restored in 24 hours.
The maximum value 24*60*60*128 -1 = 11059199.

-------------------------------------------------------------------------------
Ticks%
-------------------------------------------------------------------------------
32768 ticks/s timer.
(Example) 0 -> Ticks%
Initialize the internal timer.
At the 32 bits counter which the internal timer counts it in a speed of 32768 ticks/s, and restored at 4294967296 (=2^32).
The maximum value is 4294967295=(2^32-1)=-1
There is no processing burden compared to Ticks.

-------------------------------------------------------------------------------
TicksWait
-------------------------------------------------------------------------------
Waits a period of time at a ratio of 128 ticks/second.
(Format) Combine "Ticks" and "Wait" to get this command.
(Example) TicksWait 128
Waits for 1 second.
(Example) TicksWait -128
Waits for 1 second from the last TicksWait command run.
When it has been already over 1 second, to the next processing without waiting.
(Example) TicksWait -4
Wait for 4/128 second from the last TicksWait command run.
You can make 32fps of loops just to use one this command in the loop.

-------------------------------------------------------------------------------
Ticks%Wait
-------------------------------------------------------------------------------
Waits a period of time at a ratio of 32768 ticks/second.

-------------------------------------------------------------------------------
DATE                        [VARS]-[F3](Extend)-[F3](DATE)
TIME                        [VARS]-[F3](Extend)-[F4](TIME)
-------------------------------------------------------------------------------
Shows the current date and time according to RTC. It is stored as the string variable.
 (Example) "2017/01/17"->DATE
 (Example) DATE
  2017/01/17 TUE
  It is calculated automatically on a day.

 (Example) "23:59:59"->TIME
 (Example) TIME
  23:59:59

-------------------------------------------------------------------------------
Disp                        [SHIFT]+[VARS](PRGM)-[F6]-[F2](DISPLAY)-[F6](Disp)
-------------------------------------------------------------------------------
This is a result indication command not to suspend unlike stop command (Disps).
A party scrolls every result indication.
 (Example) Disp A+B

-------------------------------------------------------------------------------
BackLight                [VARS]-[F3](Extend)-[F5](BackLight)
-------------------------------------------------------------------------------
Setting or reading of the backlight level
 (Format) Backlight level
  Level: 0~511 (0~255: sublevel +256: main level)
 (Format) +Backlight
  Read the level of the current backlight.

-------------------------------------------------------------------------------
RefrshCtrl                [SHIFT]+[MENU](SET UP)-[F6]-[F6]-[F6]-[F1](RefrshCtrl)
RefrshTime                [SHIFT]+[MENU](SET UP)-[F6]-[F6]-[F6]-[F2](RefrshTime)
-------------------------------------------------------------------------------
RefrshCtrl and the RefrshTime command that could set the refreshment of the screen by a command.
(Example) RefrshCtrl 0
No refresh control.
(Example) RefrshCtrl 1
Refresh control is provided. Set to Grp(only graphics) mode.
(Example) RefrshCtrl 2
All refresh control is provided. Set to All(graphics+text) mode.
(Example) RefrshTime 5
Set the refresh control setting time to 5.
The screen update intervals is 5/128s.

(Format) +RefrshCtrl
(Format) +RefrshTime
Read the state of the current RefrshCtrl/RefrshTime.
(*An error will occur if command comes to the beginning of the expression.)

-------------------------------------------------------------------------------
Screen                        [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F1](Screen)
-------------------------------------------------------------------------------
Choose target VRAM and change a screen mode.
(Format 1) Screen
Change the text / graphic.
(Format 2) Screen.T or Screen.t
Change to text VRAM and change the screen mode to the text mode,
(Format 3) Screen.G or Screen.g
Change to graphic VRAM.
(Format 4) Screen 0 or SCreen 1
0: Text VRAM
1: Graphic VRAM

To convert from Screen Coordinates to Graph Coordinates.
(Usage) Screen#X,Y[,Xmin][,Xmax][,Ymin][,Ymax]
Return value to List Ans{x,y}
(Example) Screen#1,1,-6.3,6.3,-3.1,3.1
Result {74,22}

To convert from Graph Coordinates to Screen Coordinates.
(Usage) Screen%X,Y[,Xmin][,Xmax][,Ymin][,Ymax]
Return value to List Ans{x,y}
(Example) Screen%74,22,-6.3,6.3,-3.1,3.1
Result {1,1}

-Added Screen.OT option that restrain

To compose text VRAM and graphics VRAM display LCD.
(Format) Screen.O
The text VRAM becomes the synthetic screen with the graphics VRAM at the time of LCD screen transfer.
(Format) Screen.OT
VRAM does not come to change after LCD screen transfer.
(Format) Screen.N
Normal mode.

-------------------------------------------------------------------------------
PutDispDD                [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F2](PutDispDD)
_DispVram                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F3](_DispVram)
-------------------------------------------------------------------------------
Update screen.
(Format 1) PutDispDD
(Format 1) _DispVram
(*)Attention
 A transfer area is different from PutDispDD in _DispVram command.
 PutDispDD: Transfer range (0,0) -(383,191)  It is specifications compatible with genuine.
 _DispVram: Transfer range (0,-24) -(383,191) include an upper status line.

(Format 2) PutDispDD@ start line, end line
(Format 2) _DispVram@ start line, end line
 The range of the line becomes from the top (-24) to bottom (191).
 Both do same movement.
(Example) PutDispDD@ 0,23
 Transfer only the first line of Locate.

-------------------------------------------------------------------------------
PopUpWin(                [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F5](PopUpWin)
-------------------------------------------------------------------------------
Draw the pop-up window frame in current.
 (Usage) PopUpWin(n)  (1 <= n <= 6)
 (Example) PopUpWin(5)

 Message popup
 (Example) PopUpWin(11,"Message1"[,"Message1"])->A
 Return values are always 1. A screen returns the command end.

 Yes/No popup
 (Example) PopUpWin(10,"Message1"[,"Message1"])->A
 Return value
 Yes: 1
  No: 0

 (Example) PopUpWin(0)
  Push screen.

 (Example) PopUpWin(9)
  Return screen.

-------------------------------------------------------------------------------
FKeyMenu(                [SHIFT]-[F4](SKTCH)-[F2](Extend)-[F4](FKeyMenu)
-------------------------------------------------------------------------------
Display the function menu to a current VRAM.
"string" performs auto centering. (Later Ver.0.45)

（Format）FKeyMenu( n[~m], "string"/Icon # [,C/M/N/R/I/S/U/L [,FKey icon color [,Fkey back color]]]] )
  - 3rd or later arguments can be omitted.
  - "," are required even if the argument is omitted.
  - Default color of FKey icon is black and FKey back color is white.

 The order of the 3rd argument is arbitrary.
　　C: clear icon.
　　M: masked icon.
　　N: normal white icon.(default)
　　R: black icon with notch at the bottom right.
　　I: black icon with no notch at the bottom right.
　　S: black icon with no notch at the lower right indicating the selected.
　　U: display 1 dot upper.
　　L: expand the "string" display area by 2 dots left.

 (Example) FKeyMenu( 1,42)
  Draw EDIT icon at [F1] position.
 (Example) FKeyMenu (1,42,, Blue )
  Blue EDIT icon is drawn in the first function menu area.
 (Example) FKeyMenu (1,42,, Red, Blue )
  Blue EDIT icon with red background is drawn in the first function menu area.
 (Example) FKeyMenu (2, "ABCDE", RUL)
  "ABCDE" is displayed in the black icon in the second function menu area.
 (Example) FKeyMenu (3-4, "longtest", RGB(255,0,0))
  "longtest" is displayed red with the white icon in the third to fourth function menu areas.
 (Example) FKeyMenu (4, "Mask", M)
  The masked icon is displayed in the fourth function menu area.
 (Example) FKeyMenu (2, "", C)
  Clear the second function menu
 (Example) FKeyMenu (1-6, "", C)
  ClearD the first to sixth function menus.

-------------------------------------------------------------------------------
Save                        [SHIFT]+[VARS](PRGM)-[F6]-[F4](I/O)-[F6]-[F6]-[F2](Save)
Load(                        [SHIFT]+[VARS](PRGM)-[F6]-[F4](I/O)-[F6]-[F6]-[F3](Load)
-------------------------------------------------------------------------------
Read and write the data of the Mat array.
 (Example) Save "TEST",Mat A
 (Example) Load("TEST") -> Mat A
  Save the content of the Mat array and read it.
  When extension is left out, the file name becomes [.bin] to eight characters.

 (Example) Save "TEST",Mat A[5,1]
  Save till the last from Mat A[5,1].
 (Example) Load("TEST",16) -> Mat A[10,1]
  Read from data of the 16th byte of saved data in Mat A[10,1]

-------------------------------------------------------------------------------
IsExist(                [SHIFT]+[VARS](PRGM)-[F6]-[F4](I/O)-[F6]-[F6]-[F1](IsExist)
-------------------------------------------------------------------------------
When the file does not exist, 0 becomes the return value.
When the file exists, file size becomes the return value.
 (Example) IsExist("/ABC/TEST")
  If "/ABC/TEST.g3m" not exists, it becomes 0.
  When the extension is left out, the file name becomes [.bin] to eight characters.

List of files
(Format) IsExist("*.extension") -> The number of the files
(Example) IsExist("*.bmp") ->N
$Mat Ans[3]
Display the 3rd file on the list.
N: The number of the files returns.

-------------------------------------------------------------------------------
Delete                        [SHIFT]+[VARS](PRGM)-[F6]-[F4](I/O)-[F6]-[F6]-[F4](Delete)
-------------------------------------------------------------------------------
Delete the appointed file.
 (Example) Delete "TEST.dat"
  If "TEST.dat" exists, delete it.
 (Example) Delete "TEST.dat",1
  Confirm it before deletion. If "TEST.dat" exists, I delete it.
  When no extension is given, the file name becomes [.bin] to eight characters.

-------------------------------------------------------------------------------
Alias                        [OPTN]-[F5](Extend)-[F1](Alias)
-------------------------------------------------------------------------------
Alias variables by adding AliasVar command. Any character can be used as alias of actual variable character.
As for 32 variables, Mat and label can use 16 aliase.

(Example) Alias A=(alpha)
  (alpha)+100->(alpha)
  After setting the alias (alpha), (alpha) is available as variable insead of variable A. Real entity of (alpha) is A, so the above expression is identical with A+100->A
  It is the same as A+100->A.

(Example) Alias Mat A=(alpha)
   Mat(alpha)[1]+100->Mat(alpha)[1]
  After Alias command practice, I can use Mat variable A as (alpha).
  Because substance of (alpha) is A
  It is the same as Mat A[1]+100 ?? Mat A[1].

(Example) Alias Lbl A=(alpha)
  Lbl (alpha)
  Goto (alpha)
  Gosub (alpha)


(Example) Alial a=_abc_de
(Example) Alial Mat a=_abcXY
(Example) _abc_de+1->_abc_de
(Example) Mat _abcXY[1,2]+1->Mat _abcXY[1,2]
 You can use small letter variable a by _abc_de notation.
 You can use small letter line a by _abcXY notation.

(Example) Alias Lbl A=_Sub1
  Lbl _Sub1
  Goto _Sub1
  Gosub _Sub1

-------------------------------------------------------------------------------
Wait                        [VARS]-[F3](Extend)-[F2](Wait)
-------------------------------------------------------------------------------
Slow the overall execution speed. Set it by setup and [Wait] command.
When set it by setup, all the programs are affected.
 (Example) Wait 100
  Even SH3 is SH4A, but becomes the speed drop of the same.

  Wait 10 is about 1/2  speed.
  Wait 100 is about 1/10 speed.


-------------------------------------------------------------------------------
ListCmp(                [OPTN]-[F1](LIST)-[F6]-[F6]-[F5](Cmp)
-------------------------------------------------------------------------------
Compare List to List or List to value.
 (Example) ListCmp({1,2,3},{1,2,3})
  Return value 1
 (Example) ListCmp({1,2,3},{1,3})
  Return value 0
 (Example) ListCmp({1,2,3},{1,3,2})
  Return value 0
 (Example) ListCmp({1,2,3},2)
  Return value 1
 (Example) ListCmp({1,2,3},3)
  Return value 1
 (Example) ListCmp({1,2,3},4)
  Return value 0


===============================================================================
String extended command
===============================================================================
-------------------------------------------------------------------------------
StrLen(@                [SHIFT]+[VARS](PRGM)-[F6]-[F6]-[F1](STR)-[F2](Len)
-------------------------------------------------------------------------------
Added "@" option that return real byte count.
(Format) StrLen(@"ABCDE")
(Example) StrLen(@Str 1)

-------------------------------------------------------------------------------
StrRepl(                [SHIFT]+[VARS](PRGM)-[F6]-[F6]-[F1](STR)-[F5](StrRepl)
-------------------------------------------------------------------------------
 (Usage) StrRepl(String1,Find,ReplaceWith,StartAtCharPos)
 (Example) StrRepl("Hello World","World","Earth") -> "Hello Earth"
 (Example) StrRepl("abcabc","ab","ff",3) = "abcffc"
 (Example) StrRepl("abcabc","ab","ff") = "ffcffc"

-------------------------------------------------------------------------------
StrChar(                [SHIFT]+[VARS](PRGM)-[F6]-[F6]-[F3](ExStr)-[F6]-[F1](Char)
-------------------------------------------------------------------------------
(Example) StrChar("ABC",5)
  Results in "ABCABCABCABCABC"

(Example) StrChar(0x41,5)
  Results in "AAAAA"

-------------------------------------------------------------------------------
StrCenter(                [SHIFT]+[VARS](PRGM)-[F6]-[F6]-[F3](ExStr)-[F6]-[F2](Center)
-------------------------------------------------------------------------------
(Usage) StrCenter("Strings",length[,"SpacingStrings"])
(Example) StrCenter("Test",8)
 Results in "  Test  ")
(Example) StrCenter("Test",8,"*")
 Results in "**Test**"

-------------------------------------------------------------------------------
Hex(                        [SHIFT]+[VARS](PRGM)-[F6]-[F6]-[F3](ExStr)-[F6]-[F4](Hex)
-------------------------------------------------------------------------------
(Example) Hex(12345)->Str 1
 Result in "3039"
(Example) Exp("0X"+Str 1)->A
 Result in 12345

-------------------------------------------------------------------------------
Bin(                        [SHIFT]+[VARS](PRGM)-[F6]-[F6]-[F3](ExStr)-[F6]-[F5](Bin)
-------------------------------------------------------------------------------
(Example) Bin(12345)->Str 1
 Result in "11000000111001"
(Example) Exp("0B"+Str 1)->A
 Result in 12345

-------------------------------------------------------------------------------
StrBase(                [SHIFT]+[VARS](PRGM)-[F6]-[F6]-[F3](ExStr)-[F6]-[F3](Base)
-----------------------------------------------------------------------
(Usage) StrBase(Number string, Current base, Expected base)
          Current base, Expected base: 2~64
          Use character { 0-9 A-Z a-z <theta><pi>}
(Example) StrBase("579",15,12) -> "873"
          StrBase("100",13,10) -> "169"
          StrBase("123",16,3) -> "101210"
          StrBase("43981",10,16) -> "ABCD"
          StrBase("12A345AFZ",36,10) -> "2999794422815"
          StrBase("AZaz",62,10) -> "2520113"


-------------------------------------------------------------------------------
StrSplit(                [SHIFT]+[VARS](PRGM)-[F6][F6]-[F3](ExStr)-[F6]F6]-[F1](StrSplit)
-------------------------------------------------------------------------------
Divide character string by a designated letter and put it return to MatAns.
(Format) StrSplit("string","delimiter"[,start position])
 The Result returns to MatAns as character string.
(Example) StrSplit("123,4567,89",",")
  The Result of MatAns becomes ["123","4567","89"] and can access it as follows if it retrieves individual factors.
 $Mat Ans[1]="123"
 $Mat Ans[2]="4567"
 $Mat Ans[3]="89"

-------------------------------------------------------------------------------
StrAsc(                [Shift]+[VARS](PRGM)-[F6]-[F6]-[F3](ExStr)-[F6]-[F6]-[F2](StrAsc)
-------------------------------------------------------------------------------
Converts a character (in a string) into the corresponding ASCII code number.
(Example) StrAsc("Ascii")
Return value is 65(0x41).


-------------------------------------------------------------------------------
StoCapt [OPTN] - [F6] - [F6] - [F5] (CAPTURE) - [F1] (Store) (Does not work in G3M mode)
RclCapt [OPTN] - [F6] - [F6] - [F5] (CAPTURE) - [F2] (Recall)
-------------------------------------------------------------------------------
Read/write the Capt file on the storage memory. Up to 99 files can be used.
(Example) StoCapt 20
(Example) RclCapt 20

In relation to this, the file size of Pict file has been reduced by 1KB from 2KB.


===============================================================================
Other Extended Command Reference
===============================================================================
Carry it out as the command not comment after "'/".
Can describe the command to execute only C.Basic running.

(Example) '/Ticks->S
(Example) '/Ticks-S->T
 Measure time.
-------------------------------------------------------------------------------
'# Command
-------------------------------------------------------------------------------
The setting for C.Basic in comment code.

'#CBasic
'#CBASIC
'#CBDBL
'#CBdbl
'#CBINT
'#CBint
'#G1M
'#g1m
'#G3M
'#g3m
to change running mode. This is all alphabet character.

'#Break0        //disable [AC]
'#Break1        //enable [AC] (default)

'#Mat 0                //start of Mat index is 0.
'#Mat 1                //start of Mat index is 1. (default)

'#GetkeyC        //after Getkey1/2, stop of the timer and restart. (Default)
'#GetkeyR        //after Getkey1/2, reset of the timer and restart.

'#exp 0                //previous exponent display.
'#exp 1                //OS3.00 exponent display by only standard font.
'#exp 2                //OS3.00 exponent display by all font size. (Default)

'#GB0                //not use GB code. (Default)
'#GB1                //use GB code except F7xx,F9xx,E5xx,E6xx,E7xx overlapping with command / special character.
'#GB2                //use all GB code.

'#58                //fx-5800P compatible output.
'#98                //fx-9860G/CG series compatible output. (Default)

===============================================================================
Hardware Extended Commands
===============================================================================
C.Basic can execute a machine language program of SH3/SH4A on the memory.
It can access freely become only the Mat array.
The top address of the Mat array is found in VarPtr() or address operator &.
Indirect operator * are usable like C language, too.

-------------------------------------------------------------------------------
SysCall(                [SHIFT]+[VARS](PRGM)-[F6]-[F6]-[F5](EXEC)-[F1](SysCall)
-------------------------------------------------------------------------------
Call a syscall prepared for by the OS. 12 arguments can be given, but also can be left out if not needed.
(Format) SysCall( syscall number [,arg1][,arg2][,arg3][,arg4][,arg5][,arg6][,arg7][,arg8][,arg9][,arg10][,arg11][,arg12] )

(Example) Screen.G
   SysCall( 0x1D0,1,8,127,63) -> R

 System call 0x1D0 is a system routine to draw a 3xline to a screen.
 I call 1 -> R4 register, 8 -> R5 registers, 127 -> R6 registers, 63 -> R7 registers, system call 0x1D0, and R contains a return value.

-------------------------------------------------------------------------------
Call(                        [SHIFT]+[VARS](PRGM)-[F6]-[F6]-[F5](EXEC)-[F2](Call)
-------------------------------------------------------------------------------
Execute the machine language program of any address. Four arguments can be given, but also can be left out if not needed.
 (Format) Call( machine language address [argument 1] [argument 2] [argument 3] [argument 4] )
 (Example) Call( 0x8802F000,A,B,C,D) -> R
  I call A -> R4 register, A -> R5 register, A -> R6 register, A -> R7 register, a machine language program at the 0x8802F000 address, and R contains a return value.

-------------------------------------------------------------------------------
Peek(                        [SHIFT]+[VARS](PRGM)-[F6]-[F6]-[F5](EXEC)-[F4](Peek)
-------------------------------------------------------------------------------
Read data from the memory. When there is not type definition [.B][.W][.L][.F], it is byte reading.
Can rearrange it in indirect operator *.
 (Format) Peek(address)[.B][.W][.L][.F]
 (Format) *(address)[.B][.W][.L][.F])

 (Example) Peek(0x8802E000).B -> A%
 (Example) *(0x8802E000).B -> A%
  Read data of the 0x8802E000 address at A byte (1 byte) and substitute it for integer variable A%.

 (Example) Peek(0x8802E000).W -> A%
 (Example) *(0x8802E000).W -> A%
  Read data of the 0x8802E000 address in a word (2 bytes) and substitute it for integer variable A%.

 (Example) Peek(0x8802E000).L -> A%
 (Example) *(0x8802E000).L -> A%
  Read data of the 0x8802E000 address in A long word (4 bytes) and substitute it for integer variable A%.

 (Example) Peek(0x8802E000).F -> A
 (Example) *(0x8802E000).F -> A
  Read data of the 0x8802E000 address in A double precision real number (8 bytes) and substitute it for integer variable A.

-------------------------------------------------------------------------------
Poke(                        [SHIFT]+[VARS](PRGM)-[F6]-[F6]-[F5](EXEC)-[F3](Poke)
-------------------------------------------------------------------------------
Write in data at memory. When there is not type definition [.B][.W][.L][.F], it is a byte.
Can rearrange it in indirect operator *.
 (Format 1) Poke( address )[.B][.W][.L][.F], data
 (Format 1) *(address )[.B][.W][.L][.F], data)
 (Format 2) Data->Poke( address )[.B][.W][.L][.F]
 (Format 2) Data->*( address )[.B][.W][.L][.F])

 (Example) Poke(0x8802E000).B,A%
 (Example) A%->Poke(0x8802E000).B
 (Example) A%->*(0x8802E000).B

 (Example) Poke(0x8802E000).W,A%
 (Example) A%->Poke(0x8802E000).W
 (Example) A%->*(0x8802E000).W

 (Example) Poke(0x8802E000).L,A%
 (Example) A%->Poke(0x8802E000).L
 (Example) A%->*(0x8802E000).L

 (Example) Poke(0x8802E000).F,A
 (Example) A->Poke(0x8802E000).F
 (Example) A->*(0x8802E000).F

-------------------------------------------------------------------------------
VarPtr(                        [SHIFT]+[VARS](PRGM)-[F6]-[F6]-[F5](EXEC)-[F6]-[F1](VarPtr)
-------------------------------------------------------------------------------
Read form the address of the variable.
Can rearrange it in address operator &.
 (Format 1) VarPtr( variable)
 (Format 2) &( variable)

 (Example) VarPtr(A%)
 (Example) &A%
  The address of the variable of integer variable A% returns.

 (Example) VarPtr(Mat A)
 (Example) &Mat A
  Top address of Mat A returns.

 (Example) VarPtr(Mat A[20,10])
 (Example) &Mat A[20,10]
  The address that a value of Mat A[20,10] returns.

-------------------------------------------------------------------------------
ProgPtr(                [SHIFT]+[VARS](PRGM)-[F6]-[F6]-[F5](EXEC)-[F6]-[F2](ProgPtr)
-------------------------------------------------------------------------------
Read form the top of address of the source program area.
 (Example) ProgPtr()

===============================================================================
Extended Graphics Commands
===============================================================================
It is a command based MonochromeLib (by PierrotLL).
These commands act on current VRAM and do not do the processing except it at all.
The coordinate system is (0,0) -(127,63) is fixed.
It is necessary to transfer LCD using PutDispDD and _DispVRAM to display it.

-------------------------------------------------------------------------------
MonochromeLib by PierrotLL
https://wiki.planet-casio.com/fr/MonochromeLib
All features Implemented in C.Basic
Refer to MonochromeLib manual.
-------------------------------------------------------------------------------
Color: -1 transparent
Color: 0 white
Color: 1 black
Color: 2 xor
Color: 3 check color
Color: 4 random color
Color: 5 blends between Drawing color and screen color. (See below)

Added new color (2x2 dot matrix) in MonochromeLib command.
Color value: 10    11    12    13     14 (2x2 dot matrix by 1dot width)
Color value: 20    21    22    23     24 (2x2 dot matrix)
             oo    *o    *o    **     **
             oo    oo    o*    *o     **
(Example) _FillCircle 64,32,30,21

-Added random color in MonochromeLib command.
 (Usage) <command> x,y,,,color,chance
(Example) _Rectangle 0,0,127,63,0,0,4,0.5
(Example) _Rectangle 0,0,127,63,0,0,4,%50
 Fills the whole screen with random pixels, pixels have a 50% chance of being on (0.5) or %50
(Example) _FillCircle #0,0,3,4,0.5
 Makes a circle with the radius 3, the circle is filled with random pixels (on/off) pixels have a 50% chance of being on (0.5)
 If the color is 4, you can set the chance
(Example) _Rectangle 0,0,127,63,0,0,4,%10
 Fills the screen with pixels, the pixels have a 10% chance of being on

(* Color: 5 blends)
Transparency was added in color specification of parameters of ML command. (0.32-)
It composites and displays the Drawing color of the command and the screen.
(Format) _Pixel x, y, rate (rate 0.0 to 1.0)
(Format) _Pixel x, y, %rate (%rate 0 to 100)
(Example) Red _Pixel x, y, 5, %50
(Example) Red _Pixel x, y, 5, 0.5
Draw by combining the color of the screen and 50% red.

-------------------------------------------------------------------------------
Drawing objects in Graph Coordinates instead of Screen Coordinates.
  Add '#' character option to ViewWindow Coordinates.
  Support ML command,
        _Point
        _Pixel
        _PixelTest(
        _Line
        _Rect
        _Horizontal
        _Vertical
        _Circle
        _FillCircle
        _Elips
        _FillElips
        _ElipsInRct
        _FElipsInRct
(Example) ViewWindow -6.3,6.3,0,-3.1,3.1,0
 Screen.G
 _Circle #0.5,1.2,1.2,1

-------------------------------------------------------------------------------
_ClrVram                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F1](_ClrVram)
-------------------------------------------------------------------------------
 Clears the VRAM.

-------------------------------------------------------------------------------
_ClrScreen                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F2](_ClrScreen)
-------------------------------------------------------------------------------
 Clears the screen.

-------------------------------------------------------------------------------
_DispVram                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F3](_DispVram)
-------------------------------------------------------------------------------
 Copies VRAM content to screen.

-------------------------------------------------------------------------------
_Pixel                        [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F1](_Pixel)
-------------------------------------------------------------------------------
_Pixel x,y,color[,chance/brend%]
 Set the color of a dot in VRAM.
 Color:-1 transparent
 Color: 0 White
 Color: 1 Black
 Color: 2 Xor
 Color: 3 Checker

-------------------------------------------------------------------------------
_Point                        [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F2](_Point)
-------------------------------------------------------------------------------
_Point x,y,width,color[,chance/brend%]
Draws a point (square) in VRAM, centered at (x, y), with sides length (in pixel) are defined by parameter width.
(Example) _Point 10, 10, 3, 1
 Draw a black rectangle from (9, 9) to (11, 11)

-------------------------------------------------------------------------------
_PixelTest(                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F4](_PixelTest)
-------------------------------------------------------------------------------
_PixelTest(
 Returns the color of the pixel in coordinates (x, y)
 -1: out of screen
  0: White
  1: black

-------------------------------------------------------------------------------
_Line                        [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F3](_Line)
-------------------------------------------------------------------------------
_Line X1,Y1,X2,Y2,color[,chance/brend%][,Width]
 Draws a line between points in coordinates (x1, y1) and (x2, y2) using Bresenham algorithm.
(Example) _Line 0,0,127,63,1,,10

-------------------------------------------------------------------------------
_Horizontal                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F4](_Horizontal)
-------------------------------------------------------------------------------
_Horizontal y,x1,x2,color[,chance/brend%]
 Draws a horizontal line.
 This function is faster than _line with y1=y2.

-------------------------------------------------------------------------------
_Vertical                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F5](_Vertical)
-------------------------------------------------------------------------------
_Vertical x,y1,y2,color[,chance/brend%]
 Draws a vertical line.
 This function is faster than a call to _line with x1==x2.

-------------------------------------------------------------------------------
_Rectangle                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F6]-[F1](_Rectangle)
-------------------------------------------------------------------------------
_Rectangle x1,y1,x2,y2, border_width, border_color, fill_color[,chance/brend%][,angle][,center_X][,center_Y][,zoom%]
 Draws a rectangle with or without border.
 You can define the border color, and the fill color.
 If you want no border, set border_width to 0.
 If [center_X][center_Y] are omitted, The center of the drawn image is specified.

-------------------------------------------------------------------------------
_Polygon                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F6]-[F2](_Polygon)
-------------------------------------------------------------------------------
_Polygon *ary_x, *ary_y, vertices, color[,chance/brend%][,angle][,center_X][,center_Y][,zoom%]
 Draws a polygon.
 This function needs as parameters 2 arrays, containing abscissa and ordinates of the polygon vertices.
 Parameter nb_vertices should be the number of data to read in arrays.
 This function draws a line between each vertices of the polygon.
(Example)
 [[60, 75, 70, 50, 45]]->Mat X.L        // require int
 [[20, 30, 45, 45, 30]]->Mat Y.L        // require int
 Screen.G
 _ClrVRAM
 _Polygon VarPtr(Mat X), VarPtr(Mat Y), 5, 1);  (or  _Polygon &Mat X, &Mat Y, 5, 1);
 _DispVRAM (or PutDispDD)

-------------------------------------------------------------------------------
_FillPolygon                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F6]-[F3](_FillPolygon)
-------------------------------------------------------------------------------
_FillPolygon *ary_x, *ary_y, vertices, color[,chance/brend%][,angle][,center_X][,center_Y][,zoom%]
 Similar to _Polygon, but draws filled polygon.

-------------------------------------------------------------------------------
_Circle                        [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F6]-[F4](_Circle)
-------------------------------------------------------------------------------
_Circle x, y, radius, color[,chance/brend%]
 Draws a circle centered on (x, y) using Bresenham algorithm.

(Usage) _Circle
x,y,radius,color[,chance/brend%][,width][,start_angle][,end_angle][,vertex]
 (Example) _Circle 64,32,20,4,0.5,3
  3x3dot 50% circle
 (Example) _Circle 64,32,20,1,,3,0,90
  To draw 3x3dot 1/4 circle
 (Example) _Circle 64,32,20,1,,,0,360,5
  To draw pentagon ( to have an effect on setting of Draw Type )
 (Example) _Circle 64,32,20,1,,,20,380,5
  To draw shifted pentagon

-------------------------------------------------------------------------------
_FillCircle                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F6]-[F5](_FillCircle)
-------------------------------------------------------------------------------
_FillCircle x, y, radius, color[,chance/brend%]
 Similar to _Circle, but draws filled circle.

-------------------------------------------------------------------------------
_Elips                        [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F6]-[F6]-[F1](_Elips)
-------------------------------------------------------------------------------
_Elips x, y, radius1, radius2, color[,chance/brend%][,angle]
 Draws an ellipse centered on (x, y) with radiuses radius1 at radius2.
 Radius1 is distance between center and leftmost point of ellipse,
 Radius2 is distance between center and upper point of ellipse. Use the Bresenham’s algorithm.

-------------------------------------------------------------------------------
_FillElips                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F6]-[F6]-[F2](_FillElips)
-------------------------------------------------------------------------------
_FillElips x, y, radius1, radius2, color[,chance/brend%][,angle]
 Similar to _Elips, but draws a filled ellipse.

-------------------------------------------------------------------------------
_ElipsInRct                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F6]-[F6]-[F3](_ElipsInRct)
-------------------------------------------------------------------------------
_ElipsInRct x1, y1, x2, y2, color[,chance/brend%][,angle]
 This function calls _Elips. It expect rectangle coordinates, and draw an ellipse in this rectangle.

-------------------------------------------------------------------------------
_FElipsInRct                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F6]-[F6]-[F4](_FElipsInRct)
-------------------------------------------------------------------------------
_FElipsInRct x1, y1, x2, y2, color[,chance/brend%][,angle]
 Similar to _ElipsInRct, but draws a filled ellipse.

-------------------------------------------------------------------------------
_Hscroll                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F6]-[F6]-[F6]-[F1](_Hscroll)
-------------------------------------------------------------------------------
_Hscroll n[,x1,y1,x2,y2]
 Shifts all pixels in VRAM to left or right. For Example, if scroll=5, then a pixel on (2,3) will be moved on (7,3).
 If scroll is a negative value, pixels will be shift to left. When pixels reach screen boundaries, they reappear on the other side.
 You can specify the scroll area.
 (Example) _Hscroll 1,32,16,47,95
  Left scroll only (32,16)-(47,95).

-------------------------------------------------------------------------------
_Vscroll                [SHIFT]-[F4](SKTCH)-[F3](ML)-[F6]-[F6]-[F6]-[F6]-[F2](_Vscroll)
-------------------------------------------------------------------------------
_Vscroll n[,x1,y1,x2,y2]
 Similar to _Horizontal_scroll, but scroll vertically.

-------------------------------------------------------------------------------
_Bmp                        [SHIFT]-[F4](SKTCH)-[F4](BMP)-[F1](_Bmp)
-------------------------------------------------------------------------------
_Bmp *bmp, x, y, width, height [,N/O/A/X] [,C]
 These functions are made to draw images in monochrome bitmap Format. They are very useful to draw tiles and sprites in games.
 [,N] Over (g3m mode default)
 [.O] Or (g1m mode default)
 [.A] And
 [,X] Xor
 [,C] with clipping(g1m)  with clear(g3m)
(Example)
[[0,0,1,1,1,1,0,0]
 [0,1,1,1,1,1,1,0]
 [1,1,1,1,1,1,1,1]
 [1,1,1,1,1,1,1,1]
 [1,1,1,1,1,1,1,1]
 [1,1,0,1,1,1,1,0]
 [0,1,1,0,0,1,1,0]
 [0,0,1,1,1,1,0,0]]->MatB.P        //1?r?b?g?s?・
_Bmp VarPtr(Mat B), 8, 16, 8, 8, O

*Only in the case of a 1 bit Mat/List, it becomes the monochromatic Drawing.
 It becomes the 16 bits color drawing other than it.

-------------------------------------------------------------------------------
_Bmp8                        [SHIFT]-[F4](SKTCH)-[F4](BMP)-[F2](_Bmp8)
-------------------------------------------------------------------------------
_Bmp8 *bmp, x, y [,N/O/A/X] [,C]
 Draw 8*8 sized bitmap.
(Example)
 [[60, 126, 251, 253, 253, 255, 126, 60]]->Mat B.B  //byte Matrix
 _Bmp &Mat B, 8, 16, A

-------------------------------------------------------------------------------
_Bmp16                        [SHIFT]-[F4](SKTCH)-[F4](BMP)-[F3](_Bmp16)
-------------------------------------------------------------------------------
_Bmp16 *bmp, x, y [,N/O/A/X] [,C]
 Draw 16*16 sized bitmap.


-------------------------------------------------------------------------------
Additional option for MonochromeLib command.
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
BmpLoad(                [SHIFT]-[F4](SKTCH)-[F4](BMP)-[F6]-[F1](BmpLoad)
BmpSave                        [SHIFT]-[F4](SKTCH)-[F4](BMP)-[F6]-[F2](BmpSave)
-------------------------------------------------------------------------------
Bmp file load/save support.(only 1 bit mono type)
(Example) BmpLoad("TEST"),20,10
 Load TEST.bmp at coordinate (20,10).

(Example) BmpSave "TEST",10,20,100,50
 Save TEST.bmp at coordinate (10,20)-(100,50)

 (Example) BmpSave "TEST",Mat A
  Save "TEST.bmp" at current folder.
 (Example) Bombload("TEST")->Mat A
  Load bmp data to Mat A

-------------------------------------------------------------------------------
DrawMat                        [SHIFT]-[F4](SKTCH)-[F4](BMP)-[F6]-[F3](DrawMat)
-------------------------------------------------------------------------------
Drawing Mat data.
 (Usage) DrawMat Mat A[m,n], x, y, width, height [,zoomwidth][,zoomheight][,color][,chance/brend%]
 (Example)  DrawMat Mat A, 0, 0, 128, 64
 (Example)  DrawMat Mat A[10,5], 0, 0, 40, 30, %150, %250 , 4, %50
 The matrix read by BmpLoad can be used.

-------------------------------------------------------------------------------
_BmpZoom                [SHIFT]-[F4](SKTCH)-[F4](BMP)-[F4](_BmpZoom)
_BmpRotate                [SHIFT]-[F4](SKTCH)-[F4](BMP)-[F5](_BmpRotate)
_BmpZmRotate                [SHIFT]-[F4](SKTCH)-[F4](BMP)-[F6]-[F4](_BmpZmRotate)
-------------------------------------------------------------------------------
Zoom & Rotate & ZoomRotate in ML command. (based on Planet-Casio Nine stars expansion)
 (Usage) _BmpZoom &Mat , x, y, width, height [,zoomwidth][,zoomheight][,color][,chance/brend%]
 (Usage) _BmpRotate &Mat , x, y, width, height [,angle(degree)][,color][,chance/brend%]
 (Example) _BmpZoom &Mat A, 0, 0, 20, 10, 1.5, 2.5
 (Example) _BmpZoom &Mat A, 0, 0, 20, 10, %150, %250 , 4, %50
 (Example) _BmpRotate &Mat A, 0, 0, 20, 10, 45

 (Usage) _BmpZoomRotate &Mat , x, y, width, height [,zoomwidth][,zoomheight][,angle(degree)][,color][,chance/brend%]
 (Example) _BmpZoomRotate &Mat A, 0, 0, 20, 10, 1.5, 2.5, 90
 (Example) _BmpZoomRotate &Mat A, 0, 0, 20, 10, %150, %250 , 15, 4, %50

-------------------------------------------------------------------------------
_Test                        [SHIFT]-[F4](SKTCH)-[F3](ML)-[F5](_Test)
-------------------------------------------------------------------------------
 (Support command) _Point _Line _Rectangle _Circle _Polygon
  To use function to put "_Test" before support command.
 (Example) _Test_Rectangle 0,0,127,63
  To return the amount of pixels that are on in that area (0,0)-(127,63)
 (Example) _Test_Circle 62,32,20
 (Example) _Test_Point 10,10,5
 (Example) _Test_Line 10,10,100,30



===============================================================================
About external font                                                     (0.44-)
===============================================================================
An external font is usable by ASCII character(0x20~0x7E) and gaiji/kana character(0xFF80~0xFFDF).

When font files exist in current folder or @Font folder, it will automatically read the following font files at the time of file list update, and a font is replaced.
If there are not these files, it becomes the built-in font of the default.
  @LFONTA.bmp (external ASCII standard font)
  @MFONTA.bmp (external ASCII mini-font)
  @LFONTG.bmp (external gaiji character standard font)
  @MFONTG.bmp (external gaiji character mini-font)
  @LFONTK.bmp (external kana standard font)
  @MFONTK.bmp (external kana mini-font)

The bundled default external fonts are as follows.
  @LFONTK0.bmp external katakana font (standard)+
  @MFONTK0.bmp external katakana font (mini)
  @LFONTK1.bmp external hiragana font (standard)
  @MFONTK1.bmp external hiragana font (mini)
  @LFONTG0.bmp external gaiji character sample font (standard)
  @MFONTG0.bmp external gaiji character sample font (mini)

Put these fonts in the current folder,
BmpLoad(@K1)
To replace with hiragana letters.
BmpLoad(@K0)
It becomes the kana font.

-------------------------------------------------------------------------------
GetFont(                [SHIFT]-[F4](SKTCH)-[F4](BMP)-[F6]-[F6]-[F1](GetFont)
GetFontMini(                [SHIFT]-[F4](SKTCH)-[F4](BMP)-[F6]-[F6]-[F3](GetFontMini)
-------------------------------------------------------------------------------
To read font data.
(Format 1) GetFont( font code) ->Mat A
(Format 1) GetFontMini( font code) ->Mat A
(Example) GetFont(0x41) ->Mat A
 Bitmap data (18x24) of font "A" is input into 1 bit Mat A[18,24]
(Example) GetFontMini(0xFF80) ->Mat A
 The first bitmap data (13x18) of the external (0xFF80) mini-font  is input into 1 bit Mat A[13,18].

(Format 2) GetFont( "font character") ->Mat A
(Format 2) GetFontMini( "font character") ->Mat A
(Example) GetFont("A") ->Mat A
 Bitmap data (18x24) of font "A" is input into 1 bit Mat A[18,24].
(Example) GetFontMini("A") ->Mat B
 Bitmap data (13x18) of mini font "A" is input into 1 bit Mat B[13,18].

(Format 3) GetFont(@ font code) ->Mat A
(Format 3) GetFontMini(@ font code) ->Mat A
(Format 4) GetFont(@ "font character") ->Mat A
(Format 4) GetFontMini(@ "font character") ->Mat A
(Example) GetFont(@0x41) ->Mat A
(Example) GetFont(@"A") ->Mat A
 bitmap data (18x24) of built-in font "A" is input into 1 bit line Mat A[18,24].

To read external font status.
(Format 5) GetFont()
(Format 5) GetMiniFont()
 Return value is (bit0:Ascii) (bit1:Gaiji) (bit2:Kana)
(Example) When only the external kana font of the standard size is introduced,
 GetFont() return to 4
 GetMiniFont() return to 0
(Example) When the external ascii mini font and gaiji mini font are introduced,
 GetFont() return to 0
 GetMiniFont() return to 3

-------------------------------------------------------------------------------
SetFont                        [SHIFT]-[F4](SKTCH)-[F4](BMP)-[F6]-[F6]-[F2](SetFont)
SetFontMini                [SHIFT]-[F4](SKTCH)-[F4](BMP)-[F6]-[F6]-[F4](SetFontMini)
-------------------------------------------------------------------------------
To set font data.
(Format 1) SetFont font code,Mat A
(Format 1) SetFontMini font code,Mat A
(Example) SetFont 0xFF80,Mat A
 Font data of Mat A are set as data of the first one of the external font.
(Example) SetFontMini 0xFF80,Mat A
 Font data of Mat A are set as the first data of the external mini-font.

(Format 2) SetFont "font character",Mat A
(Format 2) SetFontMini "font character",Mat A
(Example) SetFont "@",Mat A
 Font data of Mat A are set as data of font "@".
(Example) SetFontMini "@",Mat B
 Font data of Mat B are set as data of mini-font "@".

-------------------------------------------------------------------------------
BmpLoad(@A
BmpLoad(@AL
BmpLoad(@AM
BmpLoad(@G
BmpLoad(@GL
BmpLoad(@GM
BmpLoad(@K
BmpLoad(@KL
BmpLoad(@KM
-------------------------------------------------------------------------------
Read font data from bitmap file.
(Format) BmpLoad(@G[ font file number])
(Format) BmpLoad(@K[ font file number])
(Format) BmpLoad(@A[ font file number])
 The font file number can 0-9.
(Example) BmpLoad(@A1)
 A font file of @LFONTA1.bmp (ASCII standard font) @MFONTA1.bmp (ASCII mini-font) is read as external ASCII font.

(Format) BmpLoad(@GM[ font file number])
(Format) BmpLoad(@GL[ font file number])
(Format) BmpLoad(@KL[ font file number])
(Format) BmpLoad(@KM[ font file number])
(Format) BmpLoad(@AL[ font file number])
(Format) BmpLoad(@AM[ font file number])
(Example) BmpLoad(@AL1)
 A font file of @LFONTA1.bmp (ASCII standard font) is read as external ASCII standard font.
(Example) BmpLoad(@AM1)
 A font file of @MFONTA1.bmp (ASCII mini-font) is read as external ASCII mini-font.

(Format) BmpLoad(@GL" file name ")
(Format) BmpLoad(@GM" file name ")
(Format) BmpLoad(@KL" file name ")
(Format) BmpLoad(@KM" file name ")
(Format) BmpLoad(@AL" file name ")
(Format) BmpLoad(@AM" file name ")
(Example) BmpLoad(@GL"MYFONTL")
 MYFONTL.bmp is read as an external gaiji standard font.
(Example) BmpLoad(@GM"MYFONTM")
 MYFONTM.bmp is read as an external gaiji mini-font.

-------------------------------------------------------------------------------
BmpSave @A
BmpSave @AL
BmpSave @AM
BmpSave @G
BmpSave @GL
BmpSave @GM
BmpSave @K
BmpSave @KL
BmpSave @KM
-------------------------------------------------------------------------------
Output font data to bitmap file.
(Format) BmpSave @G[ font file number]
 Save an external character font (standard&mini) in a current folder.
 The file name @LFONTG.bmp (standard)
 The file name @MFONTG.bmp (mini)
(Format) BmpSave @K[ font file number]
 Save a kana font (standard&mini) in a current folder.
 The file name the @LFONTK.bmp (standard) file name @MFONTK.bmp (mini)
(Format) BmpSave @A[ font file number]
 Save ASCII font (standard&mini) in a current folder.
 The file name the @LFONTA.bmp (standard) file name @MFONTA.bmp (mini)
(Format) BmpSave @@G
(Format) BmpSave @@K
(Format) BmpSave @@A
 Save in "/@Font" folder.

(Format) BmpSave @GL[font file number]
(Format) BmpSave @GM[font file number]
(Format) BmpSave @KL[font file number]
(Format) BmpSave @KM[font file number]
(Format) BmpSave @AL[font file number]
(Format) BmpSave @AM[font file number]
(Example) BmpSave @GL2
 Save an external character standard font file as of @LFONTG2.bmp (external gaiji standard font) for external font file 2.
(Example) BmpSave @GM3
 Save an external character mini-font file as of @MFONTG3.bmp (external gaiji mini-font) for external font file 3.

(Format) BmpSave @GL"<filename>"
(Format) BmpSave @GM"<filename>"
(Format) BmpSave @KL"<filename>"
(Format) BmpSave @KM"<filename>"
(Format) BmpSave @AL"<filename>"
(Format) BmpSave @AM"<filename>"
(Example) BmpSave @GL"MYFONTL"
 Save a current external gaiji standard font as "MYFONTL.bmp".
(Example) BmpSave @GM"MYFONTM"
 Save a current external gaiji mini-font as "MYFONTM.bmp".

===============================================================================
Serial communication commands (not compatible with genuine Casio Basic)
===============================================================================
 (Format) Send( data [,baud rate][,enable_exit])
 (Format) Recv( data [,baudrate][,enable_exit])
 (Format) Send38K data [,bytecount]
 (Format) Receive38k data [,bytecount]
 (Format) OpenComport38K[,baudrate][,transfermode][,enable_exit]
 (Format) CloseComport38K
 [Data]: Variable,Matrices,List
   Data is necessary to match data type of a transfer source to a transfer destination.
 [baud rate]: 0=300, 1=600, 2=1200, 3=2400, 4=4800, 5=9600, 6=19200, 7=38400, 8=57600, 9=115200 baud
   Default baud rate is 38400
 [transfermode]: 0:binary data transfer mode     1:necessary to match data type (default)
   When OpenComport38K with [transfermode:0]option, Send38K/Receive38k is binary data transfer.
 [enable_exit]: 0: not interrupt, 1: interrupt

 Send(/Recv( use alone.
 Send38K/Receive38k is necessary for OpenComport38K/CloseComport38K.

 (Example) Send(A)
 (Example) Recv(A)
 (Example) Send(Mat A)
 (Example) Recv(Mat A)

 (Example) OpenComport38K,9,0
           Send38K List 1
           CloseComport38K
 (Example) OpenComport38K,9,0
           Receive38k List 1
           CloseComport38K

-------------------------------------------------------------------------------
Beep   (only SH4A)         [SHIFT]+[VARS](PRGN) -[F6] -[F4](I/O) -[F6] -[F5](Beep)
-------------------------------------------------------------------------------
(Format) Beep [frequency][,duration (ms)]
Output square wave of the frequency designated than the 3Pin output.
(Example) Beep
Output square wave of 1KHz from 3Pin for 0.5 seconds.
(Example) Beep 440,1000
Output square wave of 440Hz from 3Pin for one second.

===============================================================================
Setup extended by C.Basic
===============================================================================
Angle: Deg/Rad/Gra
Complex Mode: Real/a+bi/r∠θ
Draw Type: Connect/Plot
Coord: on/off
Grid: on/off/Line
Axes: on/off/Scale
Label: on/off
Derivative: on/off
Background: None / Pict1-20
Plot/LineCol: Black etc.
Sketch Line: Normal/Thick/Broken/Dot/Thin

-------------------------------------------------------------------------------
Display: Fix / Sci / Nrm / Eng
  Max number of digit after decimal point can be 15. Setting 0 (zero) max digit is 16.
  Nrm1 or Nrm2 is fully compatible with genuine Casio Basic and max digit is 10.
    Nrm1: -0.01<x<0.01
    Nrm2: -0.000000001<x<0.000000001
    Other number (0 or 3 - 15) is to set max number of digit.
  Eng: select among Eng Off, Eng On (/E) and 3 digit separator (/3)
  - Related command: Eng, Norm, Fix, Sci

-------------------------------------------------------------------------------
Exp Display: E / Stdx10 / Allx10
        Select exponent character.
        E:      -1.23e99   previous character.
              Stdx10: -1.23(x10)99 new character only standard font size.
              Allx10: -1.23(x10)99 new character all font size.

- Related command: '#exp 0        //previous character.
                   '#exp 1        //new character only standard font size.
                   '#exp 2        //new character all font size.
-------------------------------------------------------------------------------
Syntax Help: On/Off
  The help display at the command input of editor.
-------------------------------------------------------------------------------
SetupRecover: On/Off
  Set it whether you return setting compatible with genuine Casio Basic after a program in Setup Recover.
-------------------------------------------------------------------------------
Command Input: C.Basic/Standard/>5800/>9800
  Select Standard(fx-CG) method or C.Basic(fx-5800P) method.
  You can change the mode of "" output specifications compatible with fx-5800P and  FX/CG.
 - Related command: '#58
                    '#98
-------------------------------------------------------------------------------
 [X]character: [0x90]/[X]
  To select character of [X/Theta/T]key.
-------------------------------------------------------------------------------
EnableExFont: on/off
  Set to use external font.
-------------------------------------------------------------------------------
Edit ExtFont: On/Off
  Enable external font in editor.
-------------------------------------------------------------------------------
Edit GB Font: On/Off/Full
  To select GB font display on editor.
  Off: normal. Not display GB font.
  On: display GB font without F7xx,F9xx,E5xx,E6xx,E7xx
  Full: display all GB font.
-------------------------------------------------------------------------------
EditFontSize: Standard/Mini/MiniMini/MiniMiniFX /+Fixed pitch/+Gap
  Set to Editor Font size.
-------------------------------------------------------------------------------
Edit Indent+: Off/1/2/4 Save-
 Enable auto indent in editor.
 Off: Disable auto indent.
  1: Set indent width to 1.
  2: Set indent width to 2.
  4: Set indent width to 4.
 Save-: delete blank spaces including indents when saving program. (=to compatible with Casio Basic)
-------------------------------------------------------------------------------
Edit LineNum: on/off
  Set to line number display.
-------------------------------------------------------------------------------
EditListChar: List / reverseL / Thick L
  Select List display character.
-------------------------------------------------------------------------------
Edit-backCol: Black/Blue/Red/Magenta/Green/Cyan/Yellow/White
 Select back color of editor.
-------------------------------------------------------------------------------
Edit-baseCol: Black/Blue/Red/Magenta/Green/Cyan/Yellow/White
 Select base color of editor.
-------------------------------------------------------------------------------
E-NumericCol: Black/Blue/Red/Magenta/Green/Cyan/Yellow/White
 Select numeric color of editor.
-------------------------------------------------------------------------------
E-Commando: Black/Blue/Red/Magenta/Green/Cyan/Yellow/White
 Select command color of editor.
-------------------------------------------------------------------------------
Ed-QuotColor: Black/Blue/Red/Magenta/Green/Cyan/Yellow/White
 Select strings color of editor.
-------------------------------------------------------------------------------
E-CommentCol: Black/Blue/Red/Magenta/Green/Cyan/Yellow/White
 Select comment color of editor.
-------------------------------------------------------------------------------
E-LineNumCol: Black/Blue/Red/Magenta/Green/Cyan/Yellow/White
 Select line number color of editor.
-------------------------------------------------------------------------------
Auto OverClk: on/off
 Set auto overclock for CG10/20
-------------------------------------------------------------------------------
Heap RAM Size: 96KB/117KB/127KB/SIZE
 Set maximum heap size of C.Basic use.
 (* You cannot change it at the time of the program editing.)
-------------------------------------------------------------------------------
Use Hidden RAM: on / off
  Set if C.Basic uses hidden RAM or not.
-------------------------------------------------------------------------------
HiddenRAM Init: on / off
  When use the hidden RAM, Mat&List at the time of C.Basic start, to initialize or not.
-------------------------------------------------------------------------------
Max Pict No: 20~99
  When use the hidden RAM, you can use more pict file.
  (*)When you change a value, Pict&Mat&List is reset.
  (*) This setting is invalid.
-------------------------------------------------------------------------------
Max List No: 52~1040
  When use the hidden RAM, you can use more List.
  (*)When you change a value, Pict&Mat&List is reset.
-------------------------------------------------------------------------------
AT DebugMode: on / off
  When [AC] break, debug mode on/off.
-------------------------------------------------------------------------------
ExitDM Popup: on / off
  Set to popup of exit Debug Mode.
-------------------------------------------------------------------------------
Break Stop: on / off
  Set if [AC] key break is accepted or not.
  When it's off, you cannot break program by [AC] key.
- Related command: '#Break0        '#Break1
-------------------------------------------------------------------------------
Exec TimeDsp: on / off / reset /%HR
  Set if program running time is displayed or not after the program quits.
  Timer starts at first line of program. ? or Disps command reset the timer.
  In the case of Getkey1/2, the timer is suspended and starts after command again.
  On reset: The timer is reset and starts again after Getkey1/2.
  %HR: use 1/32768s timer
  - Related command: '#GetkeyC  '#GetkeyR
-------------------------------------------------------------------------------
IfEnd Check: on / off
  Set if one-to-one correspondence of "If" and "IfEnd" statement is chacked or not.
-------------------------------------------------------------------------------
ACBreak: on / off
  Set ACBreak command to be enable or disable.
  - Related command: ACBreak
-------------------------------------------------------------------------------
Force Return:None/ F1/ EXE/ F1&EXE
  Force return to file mode at [AC]break.
  (Example) Force Return set to [F1]key
  -File list→[F1](EXE)→[AC]→[EXIT]… Returns to the file list.
  -File list→[EXE]→[AC]→[EXIT] …… Returns to the editor.
  -File list→[F1](EXE]→[AC]→[EXE](restart)→[AC]→[EXIT] …… Returns to the file list.
  (The operation depends on which key is pressed first.)
-------------------------------------------------------------------------------
Key 1st time: 25 ms - 1000 ms (default value is 500 ms)
  Set time before key repeat starts (in 25 ms interval)
-------------------------------------------------------------------------------
Key Rep time: 25 ms - 500 ms (default value is 125 ms)
  Set key repeat duration time (in 25 ms interval)
-------------------------------------------------------------------------------
SkipUp/Down: 1 - 9999
  Set number of skipping page for SkipUp ([SHIFT][Up]) or SkipDown ([SHIFT][Down]).
-------------------------------------------------------------------------------
Mat Dsp mode: [m,n] / [X,Y]
  Set matrix display Format in Matrix Editor page.
  Format [m,n] and [X,Y] are in transposed matrix each other, but just only the apperance on screen is different. The internal matrix data is still same, won't be changed.
-------------------------------------------------------------------------------
Matrix base: 0 / 1
  Set index of matrix starts with 0 or 1.
  When the start index is set to 0, lfet-top pixel comes to be available to use and left-yop coordinate of device coordinates can be (0, 0).
  - Related command: '#Mat 0, '#Mat 1
-------------------------------------------------------------------------------
DATE: 2017/01/17 TUE
  Set date of internal RTC. A day of the week is autmatically set.
-------------------------------------------------------------------------------
TIME: 23:59:59
  Set time of internal RTC
  - Related command: DATE, TIME
-------------------------------------------------------------------------------
Root Folder:
  [F1]: to set the root folder.
  [F2]: to set the current folder.
  - Related command:
   '#R/                // to set the root folder.
   '#R.                // to set the current folder.
-------------------------------------------------------------------------------
Favorite Col: Black/Blue/Red/Magenta/Green/Cyan/Yellow/White/16bit Color
  Select favorite file color of editor.
-------------------------------------------------------------------------------
Auto file Save: on/off
  Set to auto Save without a popup.
-------------------------------------------------------------------------------
Force g1m Save: on / off
  Set "Save automatically" or "not Save" g1m file, after run or edit of text file.
-------------------------------------------------------------------------------
Direct GB cnvt: on/off
  Set GB code without text conversion.
 (*conversion support The GB mode of the editor.)
-------------------------------------------------------------------------------
Pict mode: S.Mem / Heap / Both
  - S.Mem: Pict file is created in storage memory/SD and it takes a bit longer.
  - Heap: Pict file is not actually created, but compatible file is allocaed in main memory. (Recommended)
  - Both: Stored always in storage memory/SD.
  - Clear:Deletes the Pict compatible file created in main memory at program start every time.
-------------------------------------------------------------------------------
Storage mode: S.Mem / MainMem
  S.Mem: Files in storage memory is used for run and edit.
  Main mem: Files in Main Memory is used for run and edit.
-------------------------------------------------------------------------------
RefrshCtl DD: off / Grp / All
  Set how to refresh screen at running of display and draw command.
  Off: No extra refresh control is carried out, which is compatible with genuine Casio Basic.
  Grp: Only graphics draw commands make screen refreshed, excepting ClrText, Locate, Text, LocateYX, " " (this exception is compatible with former version of C.basic).
  All: All the display and draw commands male screen refreshed. PutDispDD should be used as may be necessary.
  Time: Set refresh control tme in interval of 1/128 sec. Defalt value is 3 then refresh control is every 1/42 sec.
        It is not refreshed when 0 is set.
  - Related command: RefrshCtrl, RefrshTime
-------------------------------------------------------------------------------
Wait count: 0~9999
 Set to wait for slowdown execution speed.
  - Related command: Wait
-------------------------------------------------------------------------------
G1M/G3M mode: auto/g3m/g1m
 Set to execute mode as default.
 - Related command:
  '#G1M
  '#g1m
  '#G3M
  '#g3m
-------------------------------------------------------------------------------
Execute mode: Dbl# / Int% / CPLX
  Set running mode as default.
  - Related command: '#CBasic, '#CBASIC, '#CBINT, '#CBint '#CBCPLX '#CBcplx
-------------------------------------------------------------------------------
